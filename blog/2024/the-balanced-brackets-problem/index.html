<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> The Balanced Brackets Problem - The Ruby Way | David W. Silva </title> <meta name="author" content="David W. Silva"> <meta name="description" content="The balanced brackets problem is a well-known problem in computer science and programming in general. It asks if a string of brackets is balanced and therefore valid, which means that the brackets are in the correct order and there are no unmatched brackets. Whovever works with Ruby for programming, will try to solve any problem in " the ruby way that is with simplicity elegance and human-centered design. can be described as a philosophy encourages programmers to write code both powerful easy understand.> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9D%92%9F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://www.davidwsilva.com//blog/2024/the-balanced-brackets-problem/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">David</span> W. Silva </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/computer_science/">Computer Science </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/projects/">projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">The Balanced Brackets Problem - The Ruby Way</h1> <p class="post-meta"> Created in September 02, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/ruby"> <i class="fa-solid fa-hashtag fa-sm"></i> ruby</a>   <a href="/blog/tag/balanced"> <i class="fa-solid fa-hashtag fa-sm"></i> balanced</a>   <a href="/blog/tag/brackets"> <i class="fa-solid fa-hashtag fa-sm"></i> brackets</a>   <a href="/blog/tag/parentheses"> <i class="fa-solid fa-hashtag fa-sm"></i> parentheses</a>   ·   <a href="/blog/category/programming"> <i class="fa-solid fa-tag fa-sm"></i> programming</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>The balanced brackets problem is a well-known problem in computer science and programming in general. It asks if a string of brackets is balanced and therefore valid, which means that the brackets are in the correct order and there are no unmatched brackets. Whovever works with Ruby for programming, will try to solve any problem in “the Ruby way”, that is, with simplicity, elegance, and human-centered design. The Ruby Way can be described as a philosophy that encourages programmers to write code that is both powerful and easy to understand. In this post I review this problem and show why classic approach for solving it remains the best one yet, with advantages in performane that justifies its choice.</p> <h1 id="reviewing-the-problem">Reviewing the Problem</h1> <p>Let’s first review the problem: Given a string containing brackets - any sequence with some arrangement including <code class="language-plaintext highlighter-rouge">"(", ")", "[", "]", "{", "}"</code> - check if the brackets are opening and closing, and in the correct order.</p> <p>Examples of strings containing balanced brackets:</p> <ul> <li><code class="language-plaintext highlighter-rouge">"{[()]}"</code></li> <li><code class="language-plaintext highlighter-rouge">"[()()]"</code></li> <li><code class="language-plaintext highlighter-rouge">"{[()]}()[]{}"</code></li> </ul> <p>Examples of strings containing unbalanced brackets:</p> <ul> <li><code class="language-plaintext highlighter-rouge">"{[("</code></li> <li><code class="language-plaintext highlighter-rouge">"{)"</code></li> <li><code class="language-plaintext highlighter-rouge">"[}"</code></li> <li><code class="language-plaintext highlighter-rouge">"{]}"</code></li> </ul> <p>and so on.</p> <p>Typically, this problem allows empty strings to be valid ones.</p> <p>So let’s summarize the constraints we need to consider before we implement a solution:</p> <ul> <li>Only strings containing brackets (round, curly, square) will be provided as input.</li> <li>Empty strings are permitted and are considered valid.</li> <li>The solution must output either <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>.</li> </ul> <h1 id="implementing-a-solution">Implementing a Solution</h1> <p>For solving this problem, imagine that I have a class named <code class="language-plaintext highlighter-rouge">BalancedBracket</code> and I will write a method named <code class="language-plaintext highlighter-rouge">check</code> to verify if any given string is valid.</p> <p>So I start by defining our class and method. Here, for simplicity, I will define <code class="language-plaintext highlighter-rouge">check</code> as a class method:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> <td class="code"><pre><span class="c1"># balanced_bracket.rb</span>
<span class="k">class</span> <span class="nc">BalancedBracket</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>Note: I could define <code class="language-plaintext highlighter-rouge">def self.check string</code> and it would work the same way since parenthesis are optional in Ruby in most cases. Here, I will leave the parenthesis while defining the method <code class="language-plaintext highlighter-rouge">check</code> for readability purposes.</p> <p>As I mentioned before, let’s try to solve this problem in the Ruby Way. I know that empty strings are considered valid. So let’s start with that:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> <td class="code"><pre><span class="c1"># balanced_bracket.rb</span>
<span class="k">class</span> <span class="nc">BalancedBracket</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="n">string</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>I can write our first test case and check our implementation so far. I will use MiniTest:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> <td class="code"><pre><span class="c1"># balanced_bracket_test.rb</span>
<span class="nb">require</span> <span class="s2">"minitest/autorun"</span>
<span class="nb">require_relative</span> <span class="s2">"balanced_bracket"</span>

<span class="k">class</span> <span class="nc">BalancedBracketTest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span>
    <span class="k">def</span> <span class="nf">test_empty_string</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s2">""</span>
        <span class="n">assert</span> <span class="no">BalancedBracket</span><span class="p">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>I can now run:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby -Itest balanced_bracket_test.rb
</code></pre></div></div> <p>which will produce the following result:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Run options: --seed 54680

# Running:

.

Finished in 0.000258s, 3875.9675 runs/s, 3875.9675 assertions/s.

1 runs, 1 assertions, 0 failures, 0 errors, 0 skips
</code></pre></div></div> <p>The first case of our problem is taken care off. Very simple, right? :-)</p> <p>I should now consider two things. The first is that, earlier, I mentioned that the balanced brackets problem is well-known in computer science which means that there is a standard way to approach it which is by using a stack. In data structures, a stack is a data structure that stores a linear, ordered sequence of items and operates on the LIFO process (Last In First Out).</p> <p>The second is that I can leverage hash maps to identify the presence of brackets in our string as well as if there is a matching pair in the right order. Let’s start by creating a variable to represent the stack and a variable to represent our hash map:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td> <td class="code"><pre><span class="c1"># balanced_bracket.rb</span>
<span class="k">class</span> <span class="nc">BalancedBracket</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="n">string</span><span class="p">.</span><span class="nf">empty?</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">brackets</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"("</span> <span class="o">=&gt;</span> <span class="s2">")"</span><span class="p">,</span> <span class="s2">"{"</span> <span class="o">=&gt;</span> <span class="s2">"}"</span><span class="p">,</span> <span class="s2">"["</span> <span class="o">=&gt;</span> <span class="s2">"]"</span><span class="p">}</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>When invoked, the class method <code class="language-plaintext highlighter-rouge">check</code> from the class <code class="language-plaintext highlighter-rouge">BalancedBracket</code> will return <code class="language-plaintext highlighter-rouge">true</code> if the string is empty and ignore the rest of the code. If the string is not empty, it will create an empty array object to represent the stack and will create a hash object with all brackets under consideration for this problem: round, curly, and square. The order of the brackets in the hash object does not matter.</p> <p>Now it’s time to write the main logic of the <code class="language-plaintext highlighter-rouge">chech</code> method which will be located inside a loop as I iterate over the string that is passed as argument to the method <code class="language-plaintext highlighter-rouge">check</code>. Ruby offers many interesting ways to iterate over collection of objects. I choose <code class="language-plaintext highlighter-rouge">each_char</code>:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td> <td class="code"><pre><span class="c1"># balanced_bracket.rb</span>
<span class="k">class</span> <span class="nc">BalancedBracket</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="n">string</span><span class="p">.</span><span class="nf">empty?</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">brackets</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"("</span> <span class="o">=&gt;</span> <span class="s2">")"</span><span class="p">,</span> <span class="s2">"{"</span> <span class="o">=&gt;</span> <span class="s2">"}"</span><span class="p">,</span> <span class="s2">"["</span> <span class="o">=&gt;</span> <span class="s2">"]"</span><span class="p">}</span>

        <span class="n">string</span><span class="p">.</span><span class="nf">each_char</span> <span class="k">do</span> <span class="o">|</span><span class="n">char</span><span class="o">|</span>
            <span class="c1"># the main logic goes here</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>Almost there. The main logic is actually pretty simple. While iterating over <code class="language-plaintext highlighter-rouge">string</code>, I will check if there is a key <code class="language-plaintext highlighter-rouge">char</code> in <code class="language-plaintext highlighter-rouge">brackets</code>. If there is, I will add it (push it) to the <code class="language-plaintext highlighter-rouge">stack</code> array as a way of keeping track of the of the left brackets we found in the string. Recall that the keys in the <code class="language-plaintext highlighter-rouge">brackets</code> object are only left brackets and their values are the corresponding right brackets. In other words, if there is a key in <code class="language-plaintext highlighter-rouge">brackets</code> that is equal to <code class="language-plaintext highlighter-rouge">char</code>, that means we found a left bracket. If we cannot find a key for the given <code class="language-plaintext highlighter-rouge">char</code> value we receive in each iteration, that means we found a right bracket and now is time to check if the right bracket matches the last left bracket added to the stack. This is where the choice for using stacks is so relevant for solving this problem: the last item to enter the stack will be the first to leave it (LIFO). We will see soon why this is so important for performance purposes.</p> <p>Back to the logic. If we cannot find a key in <code class="language-plaintext highlighter-rouge">brackets</code> that is equal to <code class="language-plaintext highlighter-rouge">char</code>, then this mean we found a right bracket. We just need to get the last left bracket added to <code class="language-plaintext highlighter-rouge">stack</code> (we pop it from the <code class="language-plaintext highlighter-rouge">stack</code> object) and compare if the corresponding matching value in our <code class="language-plaintext highlighter-rouge">brackets</code> equals to <code class="language-plaintext highlighter-rouge">char</code>. If not, we return false:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td> <td class="code"><pre><span class="c1"># balanced_bracket.rb</span>
<span class="k">class</span> <span class="nc">BalancedBracket</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="n">string</span><span class="p">.</span><span class="nf">empty?</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">brackets</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"("</span> <span class="o">=&gt;</span> <span class="s2">")"</span><span class="p">,</span> <span class="s2">"{"</span> <span class="o">=&gt;</span> <span class="s2">"}"</span><span class="p">,</span> <span class="s2">"["</span> <span class="o">=&gt;</span> <span class="s2">"]"</span><span class="p">}</span>

        <span class="n">string</span><span class="p">.</span><span class="nf">each_char</span> <span class="k">do</span> <span class="o">|</span><span class="n">char</span><span class="o">|</span>
            <span class="k">if</span> <span class="n">brackets</span><span class="p">.</span><span class="nf">key?</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
            <span class="k">else</span>
                <span class="n">left_bracket</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span>
                <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">brackets</span><span class="p">[</span><span class="n">left_bracket</span><span class="p">]</span> <span class="o">!=</span> <span class="n">char</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>Are we done? Not yet. Now, our method has the main logic but we need to write one final check before we finish it. As it currently is, the <code class="language-plaintext highlighter-rouge">check</code> method will iterate over <code class="language-plaintext highlighter-rouge">string</code> and check if there is a left bracket in it (<code class="language-plaintext highlighter-rouge">if brackets.key?(char)</code>) and if there is, it will add it to the <code class="language-plaintext highlighter-rouge">stack</code> object (<code class="language-plaintext highlighter-rouge">stack.push(char)</code>). If it does not find a left bracket (since we only accept strings containing round, curly, and square brackets), we found a right bracket which will be compared with the last left bracket we added to the <code class="language-plaintext highlighter-rouge">stack</code>. But what happens if the right bracket does not match the left bracket we just popped from the <code class="language-plaintext highlighter-rouge">stack</code>? Literally nothing. The loop will continue until it completes iterating over the input string. That mean that there will be a “residue” in the <code class="language-plaintext highlighter-rouge">stack</code>, that is, left brackets that were not matched with any right bracket. In other words, the stack won’t be empty. That shows that the input string is not valid. Therefore, to complete our <code class="language-plaintext highlighter-rouge">check</code> method, we just need to check if <code class="language-plaintext highlighter-rouge">stack</code> is empty. The input string is only valid if after going through the loop, the <code class="language-plaintext highlighter-rouge">stack</code> object is empty:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> <td class="code"><pre><span class="c1"># balanced_bracket.rb</span>
<span class="k">class</span> <span class="nc">BalancedBracket</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="n">string</span><span class="p">.</span><span class="nf">empty?</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">brackets</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"("</span> <span class="o">=&gt;</span> <span class="s2">")"</span><span class="p">,</span> <span class="s2">"{"</span> <span class="o">=&gt;</span> <span class="s2">"}"</span><span class="p">,</span> <span class="s2">"["</span> <span class="o">=&gt;</span> <span class="s2">"]"</span><span class="p">}</span>

        <span class="n">string</span><span class="p">.</span><span class="nf">each_char</span> <span class="k">do</span> <span class="o">|</span><span class="n">char</span><span class="o">|</span>
            <span class="k">if</span> <span class="n">brackets</span><span class="p">.</span><span class="nf">key?</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
            <span class="k">else</span>
                <span class="n">left_bracket</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span>
                <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">brackets</span><span class="p">[</span><span class="n">left_bracket</span><span class="p">]</span> <span class="o">!=</span> <span class="n">char</span>
            <span class="k">end</span>
        <span class="k">end</span>

        <span class="n">stack</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>Recall that in Ruby, the last line of a method is what the method returns (unless there is no previous condition that makes the method to return something else).</p> <p>Now we are done!</p> <p>So let’s update the test cases:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td> <td class="code"><pre><span class="c1"># balanced_bracket_test.rb</span>
<span class="nb">require</span> <span class="s2">"minitest/autorun"</span>
<span class="nb">require_relative</span> <span class="s2">"balanced_bracket"</span>

<span class="k">class</span> <span class="nc">BalancedBracketTest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span>
    <span class="k">def</span> <span class="nf">test_empty_string</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s2">""</span>
        <span class="n">assert</span> <span class="no">BalancedBracket</span><span class="p">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">test_valid_case</span>
        <span class="n">string1</span> <span class="o">=</span> <span class="s2">"{([])}"</span>
        <span class="n">string2</span> <span class="o">=</span> <span class="s2">"{[]()}"</span>
        <span class="n">assert</span> <span class="no">BalancedBracket</span><span class="p">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string1</span><span class="p">)</span>
        <span class="n">assert</span> <span class="no">BalancedBracket</span><span class="p">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string2</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">test_invalid_cases</span>
        <span class="n">string1</span> <span class="o">=</span> <span class="s2">"{([]"</span>
        <span class="n">string2</span> <span class="o">=</span> <span class="s2">"{[(])}"</span>
        <span class="n">refute</span> <span class="no">BalancedBracket</span><span class="p">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string1</span><span class="p">)</span>
        <span class="n">refute</span> <span class="no">BalancedBracket</span><span class="p">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string2</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>When we run the tests:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ruby -Itest balanced_bracket_test.rb
</code></pre></div></div> <p>we obtain:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Run options: --seed 21775

# Running:

...

Finished in 0.000276s, 10869.5558 runs/s, 18115.9263 assertions/s.

3 runs, 5 assertions, 0 failures, 0 errors, 0 skips
</code></pre></div></div> <p>At this point, the solution correctly address the balanced brackets problem and all test cases we wrote are passing. However, every Rubyist I know will ask the question: “Is there a better way to solve this problem?”. Something like “Can invoke the magic powers of the Ruby Way to solve this in a better way?”</p> <p>The answer might be “it depends”. It depends on what “better” means. This is what I show next.</p> <h1 id="an-alternative-solution">An Alternative Solution</h1> <p>It goes without saying that if I decide to change the implementation of <code class="language-plaintext highlighter-rouge">check</code>, the tests must continue to pass in the same way. So let’s try it.</p> <p>Here is the logic that I will follow this time: I will continue to return true if the string is empty. After that, I will start a loop and get the string.legth at each iteration and call it <code class="language-plaintext highlighter-rouge">initial_length</code>. Then, I will check if there is any matching bracket next to each other. Something like <code class="language-plaintext highlighter-rouge">()</code>, <code class="language-plaintext highlighter-rouge">[]</code>, <code class="language-plaintext highlighter-rouge">{}</code>. If there is, I will replace it by an empty string (just another way to say we will remove it from the string). So I will check the length of the string after checking for matching brackets and call it <code class="language-plaintext highlighter-rouge">final_length</code>. If there is an iteration where <code class="language-plaintext highlighter-rouge">initial_legth</code> equals <code class="language-plaintext highlighter-rouge">final_length</code>, that means we don’t have any matching brackets left in the string and it is time to exit the loop. Finally, we check if the string is empty:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td> <td class="code"><pre><span class="c1"># balanced_bracket.rb</span>
<span class="k">class</span> <span class="nc">BalancedBracket</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="n">string</span><span class="p">.</span><span class="nf">empty?</span>

        <span class="kp">loop</span> <span class="k">do</span>
            <span class="n">initial_length</span> <span class="o">=</span> <span class="n">string</span><span class="p">.</span><span class="nf">length</span>
            <span class="n">string</span><span class="p">.</span><span class="nf">gsub!</span><span class="p">(</span><span class="sr">/\(\)|\[\]|\{\}/</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
            <span class="n">final_length</span> <span class="o">=</span> <span class="n">string</span><span class="p">.</span><span class="nf">length</span>
            <span class="k">break</span> <span class="k">if</span> <span class="n">initial_length</span> <span class="o">==</span> <span class="n">final_length</span>
        <span class="k">end</span>

        <span class="n">string</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>The method <code class="language-plaintext highlighter-rouge">gsub</code> allows us to use regular expressions and stands for “global substitution”, that is, replace the pattern defined in the regular expression by the second parameter (in our case, an empty string). The symbol <code class="language-plaintext highlighter-rouge">!</code> means that we will evaluate the substitution and update the object <code class="language-plaintext highlighter-rouge">string</code> to its new state, discarding the previous one. This type of method is known in Ruby as “destructive method”.</p> <p>When we run the tests:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ruby -Itest balanced_bracket_test.rb
</code></pre></div></div> <p>we obtain:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Run options: --seed 57734

# Running:

...

Finished in 0.000371s, 8086.2476 runs/s, 13477.0794 assertions/s.

3 runs, 5 assertions, 0 failures, 0 errors, 0 skips
</code></pre></div></div> <p>The new implementation works. But is it better? Let’s see.</p> <h2 id="thoughts-on-the-stack-based-method">Thoughts on the Stack-Based Method</h2> <p>The stack-based method is straightforward and a standard approach to solving bracket validation problems. It’s easy to understand and maintain. The space complexity of the algorithm is <code class="language-plaintext highlighter-rouge">O(n)</code> as the stack grows with the number of unmatched opening brackets. Simple example: <code class="language-plaintext highlighter-rouge">((((((((((</code>. The time complexity is also <code class="language-plaintext highlighter-rouge">O(n)</code> as it iterates over <code class="language-plaintext highlighter-rouge">string</code> only once. Stack operations (push and pop) are very efficient and run in <code class="language-plaintext highlighter-rouge">O(1)</code>.</p> <h2 id="thoughts-on-the-string-based-method">Thoughts on the String-Based Method</h2> <p>The idea of modifying the string in place can be appealing for its simplicity, as it avoids the need for an additional data structure (stack). For this reason, theoretically, it uses less memory compared to the stack-based method - <code class="language-plaintext highlighter-rouge">O(1)</code> instead of <code class="language-plaintext highlighter-rouge">O(n)</code> - as we can modify the input string in place without creating any new object that might grow as we iterate string.</p> <p>However, the string-based has a potentially serious disadvantage: each time we remove a pair of brackets, the entire string needs to be reallocated (in most Ruby implementations), which can be inefficient. The time complexity of string manipulation operations like <code class="language-plaintext highlighter-rouge">gsub!</code> is <code class="language-plaintext highlighter-rouge">O(n)</code>, leading to an overall time complexity worse than <code class="language-plaintext highlighter-rouge">O(n)</code>. In fact, the exact time complexity depends on the number of times the loop runs, but in the worst case, it could approach <code class="language-plaintext highlighter-rouge">O(n²)</code> if many iterations are required.</p> <h1 id="pushing-even-further">Pushing Even Further</h1> <p>It could be surprising (or even impressive) how many different ways one can come up to solve this problem in Ruby. I tried to solve it with a one-liner and I could not find (yet) a <strong>true one-liner</strong> to solve this. I say true one-liner because I do not consider a code that is thoughtlessly concatenated just so it is executed in one line to be a trye one-liner. Let’s try something different:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="code"><pre><span class="c1"># balanced_bracket.rb</span>
<span class="k">class</span> <span class="nc">BalancedBracket</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="n">string</span><span class="p">.</span><span class="nf">chars</span><span class="p">.</span><span class="nf">each_with_object</span><span class="p">([])</span> <span class="p">{</span> <span class="o">|</span><span class="n">char</span><span class="p">,</span> <span class="n">stack</span><span class="o">|</span> 
          <span class="k">if</span> <span class="s1">'([{'</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
            <span class="n">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
          <span class="k">elsif</span> <span class="s1">')]}'</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
            <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">stack</span><span class="p">.</span><span class="nf">empty?</span> <span class="o">||</span> <span class="s1">'([{'</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">')]}'</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
          <span class="k">end</span>
        <span class="p">}.</span><span class="nf">empty?</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>In addition to <code class="language-plaintext highlighter-rouge">string.chars</code>, which returns a collection of chars from <code class="language-plaintext highlighter-rouge">string</code>, I am now using <code class="language-plaintext highlighter-rouge">each_with_object([])</code>, so we can pass an additional object to the block (“the body of the loop”). Remember when I said that Ruby had some interesting ways to iterate over collection of objects? This is just another example. The logic is really concentrated in loop block:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> <td class="code"><pre><span class="c1"># in balanced_bracket.rb</span>
<span class="k">if</span> <span class="s1">'([{'</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
    <span class="n">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="k">elsif</span> <span class="s1">')]}'</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
    <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">stack</span><span class="p">.</span><span class="nf">empty?</span> <span class="o">||</span> <span class="s1">'([{'</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">')]}'</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="k">end</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>By using <code class="language-plaintext highlighter-rouge">each_with_object</code>, we are creating a <code class="language-plaintext highlighter-rouge">stack</code> object and returning to the first version of the algorithm. Same principle, different way.</p> <p>But what about a <strong>true one-liner</strong>? I could not come up with one but I got close:</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td> <td class="code"><pre><span class="c1"># balanced_bracket.rb</span>
<span class="k">class</span> <span class="nc">BalancedBracket</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">check</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="n">string</span><span class="p">.</span><span class="nf">gsub!</span><span class="p">(</span><span class="sr">/\(\)|\[\]|\{\}/</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span> <span class="k">while</span> <span class="n">string</span><span class="p">.</span><span class="nf">sub!</span><span class="p">(</span><span class="sr">/\(\)|\[\]|\{\}/</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
        <span class="n">string</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>When we run the tests</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ruby -Itest balanced_bracket_test.rb
</code></pre></div></div> <p>we see that our test cases pass:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Run options: --seed 16154

# Running:

...

Finished in 0.000351s, 8547.0058 runs/s, 14245.0097 assertions/s.

3 runs, 5 assertions, 0 failures, 0 errors, 0 skips
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">string.gsub!(/\(\)|\[\]|\{\}/, '')</code> searches for the first occurrence of any matching bracket pair <code class="language-plaintext highlighter-rouge">()</code>, <code class="language-plaintext highlighter-rouge">[]</code>, <code class="language-plaintext highlighter-rouge">{}</code>, which runs in <code class="language-plaintext highlighter-rouge">O(n)</code>. The code <code class="language-plaintext highlighter-rouge">while string.sub!(/\(\)|\[\]|\{\}/, '')</code> will continue until no more matching pairs are found. In the worst case, if the string contains many nested brackets, the loop might run <code class="language-plaintext highlighter-rouge">n/2</code> times, where each iteration reduces the string length by 2. Overall, the time complexity will be <code class="language-plaintext highlighter-rouge">O(n) * O(n/2) = O(n²)</code>.</p> <h1 id="conclusion">Conclusion</h1> <p>I am sure that are many other ways Rubyists can come up to solve this problem in the Ruby Way. However, it is important to verify if the underlying computations are indeed more efficient than the stack-based way. For solving this particular problem, stacks are widely used, well-understood, and reliable. Overall, the stack-based approach is efficient for most typical input sizes, with time complexity <code class="language-plaintext highlighter-rouge">O(n)</code> and space complexity <code class="language-plaintext highlighter-rouge">O(n)</code>. In our particular alternative method, we reduced the space complexity to <code class="language-plaintext highlighter-rouge">O(1)</code> (which is great) at the expense of increasing the time complexity to <code class="language-plaintext highlighter-rouge">O(n²)</code> (which is is bad). I recommend anyone to try different ways to solve well-known problems. It is not just fun but it also helps us better understand what is the best solution in each case. Here, we can see that the stack-based approach is the standard solution for a reason.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/breaking-the-chain/">Breaking the Chain - The Unspoken Truth About Bad Attitudes in the Workplace and How to Eradicate Them for Good</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/metaprogramming-ruby/">Metaprogramming in Ruby</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 David W. Silva. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-computer-science",title:"Computer Science",description:"",section:"Navigation",handler:()=>{window.location.href="/computer_science/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-publications",title:"publications",description:"publications by categories in reversed chronological order.",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"nav-projects",title:"projects",description:"A growing collection of your cool projects.",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-repositories",title:"repositories",description:"Current and old coding projects.",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"dropdown-publications",title:"publications",description:"",section:"Dropdown",handler:()=>{window.location.href=""}},{id:"dropdown-projects",title:"projects",description:"",section:"Dropdown",handler:()=>{window.location.href=""}},{id:"dropdown-blog",title:"blog",description:"",section:"Dropdown",handler:()=>{window.location.href="/blog/"}},{id:"post-the-balanced-brackets-problem-the-ruby-way",title:"The Balanced Brackets Problem - The Ruby Way",description:"The balanced brackets problem is a well-known problem in computer science and programming in general. It asks if a string of brackets is balanced and therefore valid, which means that the brackets are in the correct order and there are no unmatched brackets. Whovever works with Ruby for programming, will try to solve any problem in &quot;the Ruby way&quot;, that is, with simplicity, elegance, and human-centered design. The Ruby Way can be described as a philosophy that encourages programmers to write code that is both powerful and easy to understand.",section:"Posts",handler:()=>{window.location.href="/blog/2024/the-balanced-brackets-problem/"}},{id:"post-breaking-the-chain-the-unspoken-truth-about-bad-attitudes-in-the-workplace-and-how-to-eradicate-them-for-good",title:"Breaking the Chain - The Unspoken Truth About Bad Attitudes in the Workplace...",description:"Bad attitudes in the workspace are like a baby monster that, when fed, grows strong and eats the owner and everyone around. It is a culture destroyer, a team demolisher, a dream invalidator, a motivation crusher, a corrupter of good practices, and a productivity suppressor. In this article, I write about the unspoken truth about bad attitudes and how to respond to it.",section:"Posts",handler:()=>{window.location.href="/blog/2024/breaking-the-chain/"}},{id:"post-metaprogramming-in-ruby",title:"Metaprogramming in Ruby",description:"Manipulating language constructs at runtime",section:"Posts",handler:()=>{window.location.href="/blog/2022/metaprogramming-ruby/"}},{id:"computer_science-bubble-sort",title:"Bubble Sort",description:"",section:"Computer_science",handler:()=>{window.location.href="/computer_science/cs_1/"}},{id:"computer_science-selection-sort",title:"Selection Sort",description:"",section:"Computer_science",handler:()=>{window.location.href="/computer_science/cs_2/"}},{id:"news-uk-ico-releases-privacy-notice-generator-for-smes",title:"UK ICO releases Privacy Notice Generator for SMEs",description:"",section:"News",handler:()=>{window.location.href="/news/announcement_4/"}},{id:"news-when-will-ai-s-rewards-surpass-its-risks",title:"When Will AI\u2019s Rewards Surpass Its Risks?",description:"",section:"News",handler:()=>{window.location.href="/news/announcement_3/"}},{id:"news-significant-ransom-payment-by-major-iranian-it-firm-underway",title:"Significant ransom payment by major Iranian IT firm underway",description:"",section:"News",handler:()=>{window.location.href="/news/announcement_2/"}},{id:"projects-gdpr-part-2",title:"GDPR Part 2",description:"Terminology and Basic Definitions",section:"Projects",handler:()=>{window.location.href="/projects/10_project/"}},{id:"projects-our-mission-in-iceland",title:"Our Mission in Iceland",description:"March 15 - April 1, 2022",section:"Projects",handler:()=>{window.location.href="/projects/11_project/"}},{id:"projects-gdpr-part-3",title:"GDPR Part 3",description:"Terminology and Basic Definitions",section:"Projects",handler:()=>{window.location.href="/projects/12_project/"}},{id:"projects-gdpr-part-4",title:"GDPR Part 4",description:"Identification, Classification, and Analysis",section:"Projects",handler:()=>{window.location.href="/projects/13_project/"}},{id:"projects-the-teleological-view-of-the-benefit",title:"The Teleological View of the Benefit",description:"How to use a clear view of the future to drive your efforts in the present",section:"Projects",handler:()=>{window.location.href="/projects/15_project/"}},{id:"projects-generative-ai-a-great-assistant-terrible-teacher",title:"Generative AI - A Great Assistant, Terrible Teacher",description:"With great generative power comes plenty of risks.",section:"Projects",handler:()=>{window.location.href="/projects/18_project/"}},{id:"projects-the-ubiquitous-nature-of-modern-business-intelligence",title:"The Ubiquitous Nature Of Modern Business Intelligence",description:"Data is everyhere, so it is BI",section:"Projects",handler:()=>{window.location.href="/projects/19_project/"}},{id:"projects-ai-analytics-in-manufacturing-top-strategies-from-tech-experts",title:"AI Analytics In Manufacturing - Top Strategies From Tech Experts",description:"AI in manufacturing is a promising application.",section:"Projects",handler:()=>{window.location.href="/projects/20_project/"}},{id:"projects-using-genai-for-coding-how-to-leverage-it-wisely-and-well",title:"Using GenAI For Coding? How To Leverage It Wisely And Well",description:"It&#39;s important to treat generative AI as a tool, not a full-fledged teammate.",section:"Projects",handler:()=>{window.location.href="/projects/21_project/"}},{id:"projects-the-richness-of-communication-and-the-challenges-in-the-post-covid-era",title:"The Richness of Communication and the Challenges in the Post-COVID Era",description:"Are we efficiently communicating in this new remote world?",section:"Projects",handler:()=>{window.location.href="/projects/3_project/"}},{id:"projects-what-is-trust",title:"What is Trust?",description:"What it means to trust something or someone?",section:"Projects",handler:()=>{window.location.href="/projects/4_project/"}},{id:"projects-your-weak-password-can-be-cracked-in-a-few-seconds",title:"Your Weak Password Can Be Cracked In A Few Seconds",description:"If you have to use passwords, do it the right way",section:"Projects",handler:()=>{window.location.href="/projects/5_project/"}},{id:"projects-passwords-and-human-convenience-a-match-made-in-hell",title:"Passwords and Human Convenience - A Match Made in Hell",description:"Convenience can get you in trouble",section:"Projects",handler:()=>{window.location.href="/projects/6_project/"}},{id:"projects-the-addiction-of-procrastination",title:"The Addiction of Procrastination",description:"A vice that must be overcome",section:"Projects",handler:()=>{window.location.href="/projects/7_project/"}},{id:"projects-why-startups-fail",title:"Why Startups Fail",description:"The science behind startup failure and success",section:"Projects",handler:()=>{window.location.href="/projects/8_project/"}},{id:"projects-gdpr-part-1",title:"GDPR Part 1",description:"Context, Motivations, and Goals",section:"Projects",handler:()=>{window.location.href="/projects/9_project/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%63%6F%6E%74%61%63%74@%64%61%76%69%64%77%73%69%6C%76%61.%63%6F%6D","_blank")}},{id:"socials-orcid",title:"ORCID",section:"Socials",handler:()=>{window.open("https://orcid.org/0000-0003-4498-0525","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=7sQnBGcAAAAJ","_blank")}},{id:"socials-researchgate",title:"ResearchGate",section:"Socials",handler:()=>{window.open("https://www.researchgate.net/profile/David-W-H-A-Da-Silva-2/","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/davidwilliamsilva","_blank")}},{id:"socials-x",title:"X",description:"Twitter",section:"Socials",handler:()=>{window.open("https://twitter.com/davidwsilva_","_blank")}},{id:"socials-instagram",title:"Instagram",section:"Socials",handler:()=>{window.open("https://instagram.com/davidwsilva_","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>