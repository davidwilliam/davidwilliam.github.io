<!DOCTYPE html>
<html lang="en">

<!-- Head -->

<head><!-- Metadata, OpenGraph and Schema.org -->

    <!-- Website verification -->
    <meta name="google-site-verification" content="" />

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>David W. Silva | Metaprogramming in Ruby</title>
    <meta name="author" content="David W. Silva" />
    <meta name="description" content="Manipulating language constructs at runtime" />
    <meta name="keywords" content="computer science, security, privacy, cryptography, software engineering, research, development, technology" />

    <!-- OpenGraph -->
    <meta property="og:site_name" content="David W. Silva" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="David W. Silva | Metaprogramming in Ruby" />
    <meta property="og:url" content="https://davidwsilva.com/blog/2022/metaprogramming-ruby/" />
    <meta property="og:description" content="Manipulating language constructs at runtime" />
    <meta property="og:image" content="/assets/img/metaprogramming.jpg" />
    <meta property="og:locale" content="en" />

    <!-- Twitter card -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Metaprogramming in Ruby" />
    <meta name="twitter:description" content="Manipulating language constructs at runtime" />
    <meta name="twitter:image" content="/assets/img/metaprogramming.jpg" />
    <meta name="twitter:site" content="@davidwsilva_" />
    <meta name="twitter:creator" content="@davidwsilva_" />

    <!-- Schema.org -->
    <script type="application/ld+json">
      {
        "author":
        {
          "@type": "Person",
          "name": "David W. Silva"
        },
        "url": "https://davidwsilva.com/blog/2022/metaprogramming-ruby/",
        "@type": "WebSite",
        "description": "Manipulating language constructs at runtime",
        "headline": "Metaprogramming in Ruby",
        "sameAs": ["https://orcid.org/0000-0003-4498-0525", "https://scholar.google.com/citations?user=7sQnBGcAAAAJ", "https://www.researchgate.net/profile/David-W-H-A-Da-Silva-2", "https://github.com/davidwilliam", "https://www.linkedin.com/in/davidwilliamsilva", "https://twitter.com/davidwsilva_", "https://www.algemetric.com/"],
        "name": "David W. Silva",
        "@context": "https://schema.org"
      }
    </script>


<!-- Bootstrap & MDB -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css"
    rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css"
    integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css"
    integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
<link rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css"
    integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
    href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css"
    media="none" id="highlight_theme_light" />

<!-- Styles -->
 <link rel="shortcut icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ùíü</text></svg>">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://davidwsilva.com/blog/2022/metaprogramming-ruby/">

    <!-- Dark Mode -->
    
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css"
        media="none" id="highlight_theme_dark" />

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-PV4GTH3');</script>
    <!-- End Google Tag Manager -->
</head>

<!-- Body -->

<body
  class="fixed-top-nav ">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PV4GTH3" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="https://davidwsilva.com/"><span class="font-weight-bold">David</span> W.  Silva</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">blog</a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/miscellaneous/">miscellaneous</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">publications</a>
              </li>

              <!-- Toogle theme mode -->
              <div class="toggle-container">
                <a id="light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </a>
              </div>
            </ul>
          </div>
        </div>
      </nav>
    </header>


  <!-- Content -->
  <div class="container mt-5">
    <!-- _layouts/post.html -->

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Metaprogramming in Ruby</h1>
    <p class="post-meta">February 26, 2022</p>
    <p class="post-tags">
      <a href="/blog/2022"> <i class="fas fa-calendar fa-sm"></i> 2022 </a>
      ¬† ¬∑ ¬†
        <a href="/blog/tag/metaprogramming">
          <i class="fas fa-hashtag fa-sm"></i> metaprogramming</a> ¬†
          <a href="/blog/tag/ruby">
          <i class="fas fa-hashtag fa-sm"></i> ruby</a> ¬†
          <a href="/blog/tag/code">
          <i class="fas fa-hashtag fa-sm"></i> code</a> ¬†
          
      ¬† ¬∑ ¬†
        <a href="/blog/category/programming">
          <i class="fas fa-tag fa-sm"></i> programming</a> ¬†
          

    </p>
  </header>

  <article class="post-content">
    <p>Ruby is a programming language created by <a href="https://github.com/matz" target="_blank" rel="noopener noreferrer">Yukihiro Matsumoto</a> (better known as Matz) a form of compilation of everything he liked the best about his favorite languages: <a href="https://www.perl.org/" target="_blank" rel="noopener noreferrer">Perl</a>, <a href="http://www.smalltalk.org/" target="_blank" rel="noopener noreferrer">Smaltalk</a>, <a href="https://www.eiffel.org/" target="_blank" rel="noopener noreferrer">Eiffel</a>, <a href="http://www.getadanow.com/" target="_blank" rel="noopener noreferrer">Ada</a>, and <a href="https://lisp-lang.org/" target="_blank" rel="noopener noreferrer">Lisp</a>. Matz was motivated to create a new language by balancing functional with imperative programming.</p>

<p>One of the first reactions people have when first interacting with Ruby is to say: ‚ÄúWow, this is very simple!‚Äù Matz, however, states that his goal is to make Ruby <em>natural</em>, not <em>simple</em>. Matz remarks, ‚ÄúRuby is simple in appearance, but is very complex inside, just like our human body.‚Äù</p>

<p>On its official page, Ruby is described as a ‚Äúdynamic, open-source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write.‚Äù There is much more that can be said about Ruby, even in an introductory fashion, but this initial description is, in my view, spot on.</p>

<p>When I use Ruby, I am not thinking about some of the mechanics of programming. Instead, I am mostly thinking about the result I seek to produce. Matz wanted Ruby code to be easily read by humans. Ruby code is meant to be very elegant and simple, which makes it my favorite language for <em>prototyping</em>.</p>

<h1 id="what-is-mettaprogramming">What Is Mettaprogramming?</h1>

<p>If elegance, simplicity, and the natural aspect of its syntax are already great ingredients for prototyping, my favorite thing about Ruby is something yet more intriguing: <em>metaprogramming</em>!</p>

<p>Informally, metaprogramming is often refferred to as ‚Äúwriting code that writes code‚Äù. If you search online, this is the most popular definition of metaprogramming: ‚ÄúCode that writes code.‚Äù Well, I‚Äôm not too fond of this definition. The reason is straightforward. Consider the following C++ code:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td>
<td class="code"><pre><span class="c1">// example.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">ofstream</span> <span class="n">ofs</span><span class="p">(</span><span class="s">"main.cpp"</span><span class="p">);</span>
  <span class="n">string</span> <span class="n">code</span> <span class="o">=</span> <span class="s">"#include &lt;iostream&gt;</span><span class="se">\n</span><span class="s">"</span>
                <span class="s">"using namespace std;</span><span class="se">\n\n</span><span class="s">"</span>
                <span class="s">"int main()</span><span class="se">\n</span><span class="s">"</span>
                <span class="s">"{</span><span class="se">\n</span><span class="s">"</span>
                <span class="s">"  int a = 2;</span><span class="se">\n</span><span class="s">"</span>
                <span class="s">"  int b = 3;</span><span class="se">\n\n</span><span class="s">"</span>
                <span class="s">"  cout &lt;&lt; </span><span class="se">\"</span><span class="s">a = </span><span class="se">\"</span><span class="s"> &lt;&lt; a &lt;&lt; endl;</span><span class="se">\n</span><span class="s">"</span>
                <span class="s">"  cout &lt;&lt; </span><span class="se">\"</span><span class="s">b = </span><span class="se">\"</span><span class="s"> &lt;&lt; b &lt;&lt; endl;</span><span class="se">\n</span><span class="s">"</span>
                <span class="s">"  cout &lt;&lt; </span><span class="se">\"</span><span class="s">a + b = </span><span class="se">\"</span><span class="s"> &lt;&lt; a + b &lt;&lt; endl;</span><span class="se">\n</span><span class="s">"</span>
                <span class="s">"  cout &lt;&lt; </span><span class="se">\"</span><span class="s">a * b = </span><span class="se">\"</span><span class="s"> &lt;&lt; a * b &lt;&lt; endl;</span><span class="se">\n\n</span><span class="s">"</span>
                <span class="s">"  return 0;</span><span class="se">\n</span><span class="s">"</span>
                <span class="s">"}"</span><span class="p">;</span>
  <span class="n">ofs</span> <span class="o">&lt;&lt;</span> <span class="n">code</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>When I run <code class="language-plaintext highlighter-rouge">g++ example.cpp -o example --std=c++11 &amp;&amp; ./example</code>, a new file <code class="language-plaintext highlighter-rouge">main.cpp</code> will be created, which contains the following code:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td>
<td class="code"><pre><span class="c1">// main.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a = "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"b = "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a + b = "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a * b = "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>When I run <code class="language-plaintext highlighter-rouge">g++ main.cpp -o main --std=c++11 &amp;&amp; ./main</code>, I obtain:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = 2
b = 3
a + b = 5
a * b = 6
</code></pre></div></div>

<p>This is a naive example of ‚Äúcode that writes code.‚Äù Ok, maybe too naive, but the idea here is to illustrate the limitations of this popular definition of metaprogramming. A code that writes code is not interesting in itself. How code writes code and what you can do with that is an entirely different story.</p>

<p>Paolo Perrotta wrote <a href="https://pragprog.com/titles/ppmetr2/metaprogramming-ruby-2/" target="_blank" rel="noopener noreferrer">a wonderful book</a> about metaprogramming in Ruby. Perrotta describes Ruby source code as ‚Äúa world teeming with vibrant citizens including variables, classes, and methods.‚Äù These citizens are <em>language constructs</em>. Therefore a more technical (and much more meaningful) definition of metaprogramming is <em>writing code that manipulates language constructs at runtime.</em> This concept is so important that I will break it down for better visibility:</p>

<ul>
  <li>What: writing code that manipulate language constructs.</li>
  <li>When: at runtime.</li>
</ul>

<p>I like the second definition much better. Not every language can do that, and the way Ruby achieves this dynamic manipulation of language constructs makes it incredibly elegant and powerful.</p>

<p>All I can do in a single blog post is to scratch the surface of metaprogramming in Ruby. For that, I invite you to look at five, amongst other building blocks of metaprogramming in Ruby: Dynamic Dispatch, Dynamic Methods, Ghost Methods, Dynamic Proxy, and Blank Slate.</p>

<h1 id="language-constructs">Language Constructs</h1>

<blockquote>
  <p>For all the examples in this post, I used Ruby 3.1.0p0 (2021-12-25 revision fb4df44d16) [x86_64-darwin19].</p>
</blockquote>

<p>When we create a class in Ruby, that class inherits properties and behaviors from other default classes unless we decide otherwise. These classes are called ‚Äúancestors.‚Äù They provide fundamental functionalities for any custom class in their lineage. We can check what are the ancestors of my class as follows:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td>
<td class="code"><pre><span class="k">class</span> <span class="nc">MySimpleClass</span>
<span class="k">end</span>

<span class="no">MySimpleClass</span><span class="p">.</span><span class="nf">ancestors</span>
<span class="c1"># =&gt; [MySimpleClass, Object, PP::ObjectMixin, Kernel, BasicObject]</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>We can check what each of these ancestors is by checking their associated classes:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">MySimpleClass</span><span class="p">.</span><span class="nf">ancestors</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:class</span><span class="p">)</span>
<span class="c1"># =&gt; [Class, Class, Module, Module, Class]</span></code></pre></figure>

<p>We can also list what ‚Äúfundamental functionalities‚Äù are inherited when we create a class in Ruby by executing:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">BasicObject</span><span class="p">.</span><span class="nf">methods</span>
<span class="c1"># =&gt; [:allocate,  :superclass,  :subclasses,  :new,  :instance_method,  :public_instance_method,  :&lt;=&gt;,  :define_method,  :&lt;=,  :&gt;=,  :==,  :===,  :included_modules,  :include?,  :ancestors,  :attr,  :attr_reader,  :attr_writer,  :attr_accessor,  :instance_methods,  :public_instance_methods,  :protected_instance_methods,  :private_instance_methods,  :constants,  :freeze,  :inspect,  :const_set,  :const_get,  :const_source_location,  :const_defined?,  :class_variable_set,  :class_variables,  :remove_class_variable,  :class_variable_get,  :const_missing,  :class_variable_defined?,  :&lt;,  :private_constant,  :&gt;,  :singleton_class?,  :public_constant,  :deprecate_constant,  :prepend,  :include,  :module_exec,  :to_s,  :module_eval,  :class_exec,  :class_eval,  :pretty_print_cycle,  :remove_method,  :undef_method,  :alias_method,  :method_defined?,  :public_method_defined?,  :private_method_defined?,  :name,  :protected_method_defined?,  :public_class_method,  :private_class_method,  :autoload,  :autoload?,  :pretty_print,  :pretty_print_instance_variables,  :pretty_print_inspect,  :singleton_class,  :dup,  :itself,  :taint,  :tainted?,  :untaint,  :untrust,  :untrusted?,  :trust,  :methods,  :singleton_methods,  :protected_methods,  :private_methods,  :public_methods,  :instance_variables,  :instance_variable_get,  :instance_variable_set,  :instance_variable_defined?,  :remove_instance_variable,  :instance_of?,  :kind_of?,  :is_a?,  :display,  :hash,  :public_send,  :class,  :frozen?,  :tap,  :yield_self,  :then,  :extend,  :clone,  :method,  :public_method,  :singleton_method,  :define_singleton_method,  :=~,  :!~,  :nil?,  :eql?,  :respond_to?,  :object_id,  :send,  :to_enum,  :enum_for,  :pretty_inspect,  :__send__,  :!,  :instance_eval,  :instance_exec,  :!=,  :equal?,  :__id__]</span></code></pre></figure>

<p>You see a long list of methods inherited by the classes/modules in the BasicObject‚Äôs lineage. We can ask the list of methods for the module <code class="language-plaintext highlighter-rouge">Kernel</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Kernel</span><span class="p">.</span><span class="nf">methods</span>
<span class="c1"># =&gt; [:puts,  :readline,  :readlines,  :p,  :Complex,  :Float,  :caller,  :caller_locations,  :set_trace_func,  :sprintf,  :format,  :Integer,  :String,  :Array,  :Hash,  :local_variables,  :fork,  :Pathname,  :exit,  :pp,  :warn,  :test,  :raise,  :gets,  :fail,  :global_variables,  :__method__,  :__callee__,  :__dir__,  :proc,  :lambda,  :eval,  :iterator?,  :block_given?,  :catch,  :throw,  :loop,  :sleep,  :rand,  :srand,  :trap,  :select,  :`,  :trace_var,  :untrace_var,  :load,  :at_exit,  :require_relative,  :require,  :autoload?,  :autoload,  :binding,  :Rational,  :exec,  :exit!,  :system,  :spawn,  :abort,  :syscall,  :open,  :printf,  :print,  :putc,  :instance_method,  :public_instance_method,  :&lt;=&gt;,  :define_method,  :&lt;=,  :&gt;=,  :==,  :===,  :included_modules,  :include?,  :ancestors,  :attr,  :attr_reader,  :attr_writer,  :attr_accessor,  :instance_methods,  :public_instance_methods,  :protected_instance_methods,  :private_instance_methods,  :constants,  :freeze,  :inspect,  :const_set,  :const_get,  :const_source_location,  :const_defined?,  :class_variable_set,  :class_variables,  :remove_class_variable,  :class_variable_get,  :const_missing,  :class_variable_defined?,  :&lt;,  :private_constant,  :&gt;,  :singleton_class?,  :public_constant,  :deprecate_constant,  :prepend,  :include,  :module_exec,  :to_s,  :module_eval,  :class_exec,  :class_eval,  :pretty_print_cycle,  :remove_method,  :undef_method,  :alias_method,  :method_defined?,  :public_method_defined?,  :private_method_defined?,  :name,  :protected_method_defined?,  :public_class_method,  :private_class_method,  :pretty_print,  :pretty_print_instance_variables,  :pretty_print_inspect,  :singleton_class,  :dup,  :itself,  :taint,  :tainted?,  :untaint,  :untrust,  :untrusted?,  :trust,  :methods,  :singleton_methods,  :protected_methods,  :private_methods,  :public_methods,  :instance_variables,  :instance_variable_get,  :instance_variable_set,  :instance_variable_defined?,  :remove_instance_variable,  :instance_of?,  :kind_of?,  :is_a?,  :display,  :hash,  :public_send,  :class,  :frozen?,  :tap,  :yield_self,  :then,  :extend,  :clone,  :method,  :public_method,  :singleton_method,  :define_singleton_method,  :=~,  :!~,  :nil?,  :eql?,  :respond_to?,  :object_id,  :send,  :to_enum,  :enum_for,  :pretty_inspect,  :__send__,  :!,  :instance_eval,  :instance_exec,  :!=,  :equal?,  :__id__]</span></code></pre></figure>

<p>Now you see an even longer list of methods than before. We can check the sizes of these lists:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="code"><pre><span class="no">BasicObject</span><span class="p">.</span><span class="nf">methods</span><span class="p">.</span><span class="nf">size</span> <span class="c1"># =&gt; 118</span>
<span class="no">Kernel</span><span class="p">.</span><span class="nf">methods</span><span class="p">.</span><span class="nf">size</span> <span class="c1"># =&gt; 175</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>We can also see precisely what the methods that belong to <code class="language-plaintext highlighter-rouge">Kernel</code> but not to <code class="language-plaintext highlighter-rouge">BasicObject</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Kernel</span><span class="p">.</span><span class="nf">methods</span> <span class="o">-</span> <span class="no">BasicObject</span><span class="p">.</span><span class="nf">methods</span>
<span class="c1"># =&gt; [:puts,  :readline,  :readlines,  :p,  :Complex,  :Float,  :caller,  :caller_locations,  :set_trace_func,  :sprintf,  :format,  :Integer,  :String,  :Array,  :Hash,  :local_variables,  :fork,  :exit,  :pp,  :Pathname,  :warn,  :test,  :raise,  :gets,  :fail,  :global_variables,  :__method__,  :__callee__,  :__dir__,  :proc,  :lambda,  :eval,  :iterator?,  :block_given?,  :catch,  :throw,  :loop,  :sleep,  :rand,  :srand,  :trap,  :select,  :`,  :trace_var,  :untrace_var,  :load,  :at_exit,  :require_relative,  :require,  :binding,  :Rational,  :exec,  :exit!,  :system,  :spawn,  :abort,  :syscall,  :open,  :printf,  :print,  :putc]</span></code></pre></figure>

<p>But wait:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Object</span><span class="p">.</span><span class="nf">methods</span><span class="p">.</span><span class="nf">size</span> <span class="c1"># =&gt; 118</span></code></pre></figure>

<p>What is going on here? Shouldn‚Äôt <code class="language-plaintext highlighter-rouge">Object</code> have at least 175 methods like <code class="language-plaintext highlighter-rouge">Kernel</code>? Actually, no. Ruby does not support multiple inheritances. One of the methods defined in <code class="language-plaintext highlighter-rouge">BasicObject</code> is <code class="language-plaintext highlighter-rouge">:superclass</code>. Obviously, <code class="language-plaintext highlighter-rouge">BasicObject</code> does not have a superclass (parent class):</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">BasicObject</span><span class="p">.</span><span class="nf">superclass</span> <span class="c1"># =&gt; nil</span></code></pre></figure>

<p>But <code class="language-plaintext highlighter-rouge">Object</code> has:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Object</span><span class="p">.</span><span class="nf">superclass</span> <span class="c1"># =&gt; BasicObject</span></code></pre></figure>

<p>So <code class="language-plaintext highlighter-rouge">Object</code> inherits from <code class="language-plaintext highlighter-rouge">BasicObject</code>. We can even check the following:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Object</span><span class="p">.</span><span class="nf">methods</span> <span class="o">==</span> <span class="no">BasicObject</span><span class="p">.</span><span class="nf">methods</span> <span class="c1"># =&gt; true</span></code></pre></figure>

<p>What is <code class="language-plaintext highlighter-rouge">PP::ObjectMixin</code> and <code class="language-plaintext highlighter-rouge">Kernel</code> doing ‚Äúabove‚Äù <code class="language-plaintext highlighter-rouge">Object</code> when we look at the ancestors of <code class="language-plaintext highlighter-rouge">MySimpleClass</code>? Simple: as we saw before, <code class="language-plaintext highlighter-rouge">PP::ObjectMixin</code> and <code class="language-plaintext highlighter-rouge">Kernel</code> are modules, not classes, and we know that a class can only have one superclass. While we can create a class that inherits from another class (and just one), we can <code class="language-plaintext highlighter-rouge">include</code> as many modules we want using the principle of <em>composition</em>. Therefore we can check:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Object</span><span class="p">.</span><span class="nf">included_modules</span>
<span class="c1"># =&gt; [PP::ObjectMixin, Kernel]</span>
<span class="no">MySimpleClass</span><span class="p">.</span><span class="nf">included_modules</span>
<span class="c1"># =&gt; [PP::ObjectMixin, Kernel]</span></code></pre></figure>

<p>When I created <code class="language-plaintext highlighter-rouge">MySimpleClass</code>, it automatically inherited from <code class="language-plaintext highlighter-rouge">Object</code>, which includes the modules <code class="language-plaintext highlighter-rouge">PP::ObjectMixin</code> and <code class="language-plaintext highlighter-rouge">Kernel</code>, and therefore <code class="language-plaintext highlighter-rouge">MySimpleClass</code> also include these modules. The correct way to read the ancestors list is as follows: <code class="language-plaintext highlighter-rouge">MySimpleClass</code> inherits from <code class="language-plaintext highlighter-rouge">Object</code>, <code class="language-plaintext highlighter-rouge">Object</code> includes <code class="language-plaintext highlighter-rouge">PP::ObjectMixin</code> and <code class="language-plaintext highlighter-rouge">Kernel</code>, and <code class="language-plaintext highlighter-rouge">Object</code> inherits from <code class="language-plaintext highlighter-rouge">BasicObject</code>.</p>

<p>How are modules included in a class? Consider the following module:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td>
<td class="code"><pre><span class="k">module</span> <span class="nn">MyModule</span>
  <span class="k">def</span> <span class="nf">my_first_method</span>
    <span class="nb">puts</span> <span class="s2">"My first method"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">my_second_method</span>
    <span class="nb">puts</span> <span class="s2">"My second method"</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Now we create <code class="language-plaintext highlighter-rouge">MySimpleClass</code> and include <code class="language-plaintext highlighter-rouge">MyModule</code> as follows:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td>
<td class="code"><pre><span class="k">class</span> <span class="nc">MySimpleClass</span>
  <span class="kp">include</span> <span class="no">MyModule</span>

  <span class="k">def</span> <span class="nf">some_method</span>
    <span class="nb">puts</span> <span class="s2">"Some method"</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>And we can check what instance methods we have now available in <code class="language-plaintext highlighter-rouge">MySimpleClass</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">MySimpleClass</span><span class="p">.</span><span class="nf">instance_methods</span> <span class="o">-</span> <span class="no">Object</span><span class="p">.</span><span class="nf">methods</span>
<span class="c1"># =&gt; [:some_method, :my_first_method, :my_second_method]</span></code></pre></figure>

<p>In ruby, the top-level object (something similar to the scope of main in C) is <code class="language-plaintext highlighter-rouge">Object</code>, and we know <code class="language-plaintext highlighter-rouge">Object</code> includes <code class="language-plaintext highlighter-rouge">Kernel</code>. Therefore, the methods defined in Kernel are available to <code class="language-plaintext highlighter-rouge">Object</code> and any of its descendants without the need to refer to Kernel explicitly! This includes methods we use without even thinking, such as <code class="language-plaintext highlighter-rouge">puts</code>, <code class="language-plaintext highlighter-rouge">rand</code>, <code class="language-plaintext highlighter-rouge">raise</code>, <code class="language-plaintext highlighter-rouge">catch</code>, <code class="language-plaintext highlighter-rouge">throw</code>, and all the others defined in <code class="language-plaintext highlighter-rouge">Kernel</code>. This is why we can execute:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">puts</span> <span class="s2">"Hello!"</span>
<span class="c1"># =&gt; Hello!</span></code></pre></figure>

<p>instead of</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Kernel</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"Hello!"</span>
<span class="c1"># =&gt; Hello!</span></code></pre></figure>

<p>In fact, when you are running IRB (interactive Ruby), a REPL (Read-Eval-Print-Loop) environment, and you type</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">self</span>
<span class="c1"># =&gt; main</span></code></pre></figure>

<p>you get <code class="language-plaintext highlighter-rouge">main</code>. We never define <code class="language-plaintext highlighter-rouge">main</code> in Ruby. This is just to indicate that the top-level object in Ruby (a language where everything is an object), is an instance of <code class="language-plaintext highlighter-rouge">Object</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">self</span><span class="p">.</span><span class="nf">class</span>
<span class="c1"># =&gt; Object</span></code></pre></figure>

<h2 id="manipulating-language-constructs">Manipulating Language Constructs</h2>

<p>Let‚Äôs take a look at how Ruby allows us to interact with its ‚Äúvibrant citizens,‚Äù as Perrotta describes Ruby‚Äôs language constructs. When you hear that Ruby is a dynamic language, you should know that Ruby is pretty serious about that.</p>

<p>As an example, consider the following class:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td>
<td class="code"><pre><span class="k">class</span> <span class="nc">AnotherClass</span>
  <span class="nb">attr_reader</span> <span class="ss">:full_name</span><span class="p">,</span> <span class="ss">:dob</span>
  <span class="nb">attr_accessor</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:phone</span><span class="p">,</span> <span class="ss">:zipcode</span>

  <span class="no">SEPARATOR</span> <span class="o">=</span> <span class="s2">"-"</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">dob</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">phone</span><span class="p">,</span> <span class="n">zipcode</span><span class="p">)</span>
    <span class="vi">@first_name</span> <span class="o">=</span> <span class="n">first_name</span>
    <span class="vi">@last_name</span> <span class="o">=</span> <span class="n">last_name</span>
    <span class="vi">@email</span> <span class="o">=</span> <span class="n">email</span>
    <span class="vi">@dob</span> <span class="o">=</span> <span class="n">parse_date</span><span class="p">(</span><span class="n">dob</span><span class="p">)</span>
    <span class="vi">@phone</span> <span class="o">=</span> <span class="n">parse_phone</span><span class="p">(</span><span class="n">phone</span><span class="p">)</span>
    <span class="vi">@zipcode</span> <span class="o">=</span> <span class="n">zipcode</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">full_name</span>
    <span class="nb">name</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">contact</span>
    <span class="s2">"
    </span><span class="si">#{</span><span class="n">contact_full_name</span><span class="si">}</span><span class="s2">
    </span><span class="si">#{</span><span class="n">email</span><span class="si">}</span><span class="s2">
    </span><span class="si">#{</span><span class="n">phone</span><span class="si">}</span><span class="s2">
    </span><span class="si">#{</span><span class="n">zipcode</span><span class="si">}</span><span class="s2">
    "</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">name</span>
    <span class="p">[</span><span class="vi">@first_name</span><span class="p">,</span> <span class="vi">@last_name</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">contact_full_name</span>
    <span class="nb">name</span><span class="p">.</span><span class="nf">reverse</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">parse_input</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span><span class="n">input</span><span class="p">)</span>
    <span class="n">positions</span><span class="p">.</span><span class="nf">each</span><span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">input</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="no">SEPARATOR</span><span class="p">)}</span>
    <span class="n">input</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">parse_date</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
    <span class="n">parse_input</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span><span class="n">date</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">parse_phone</span><span class="p">(</span><span class="n">phone</span><span class="p">)</span>
    <span class="n">parse_input</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span><span class="n">phone</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>We can now interact with Ruby‚Äôs vibrant citizens in a number of ways. First, we instantiate an object of <code class="language-plaintext highlighter-rouge">AnotherClass</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td>
<td class="code"><pre><span class="n">obj</span> <span class="o">=</span> <span class="no">AnotherClass</span><span class="p">.</span><span class="nf">new</span> <span class="s2">"John"</span><span class="p">,</span> <span class="s2">"Smith"</span><span class="p">,</span> <span class="s2">"19950223"</span><span class="p">,</span> <span class="s2">"jsmith@domain.com"</span><span class="p">,</span> <span class="s2">"8205550123"</span><span class="p">,</span> <span class="s2">"501234"</span>
<span class="c1"># =&gt; #&lt;AnotherClass:0x00007f98c38e08d8 @first_name="John", @last_name="Smith", @email="jsmith@domain.com", @dob="1995-02-23", @phone="820-555-0123", @zipcode="501234"&gt;</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">full_name</span>
<span class="c1"># =&gt; John Smith</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">contact</span>
<span class="c1"># =&gt;    Smith, John</span>
<span class="c1">#       jsmith@domain.com</span>
<span class="c1">#       820-555-0123</span>
<span class="c1">#       501234</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Then we information from <code class="language-plaintext highlighter-rouge">obj</code> and <code class="language-plaintext highlighter-rouge">AnotherClass</code> such as:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td>
<td class="code"><pre><span class="n">obj</span><span class="p">.</span><span class="nf">class</span>
<span class="c1"># =&gt; AnotherClass</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">ancestors</span>
<span class="c1"># =&gt; [AnotherClass, Object, PP::ObjectMixin, Kernel, BasicObject]</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">instance_variables</span>
<span class="c1"># =&gt; [:@first_name, :@last_name, :@email, :@dob, :@phone, :@zipcode]</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">public_methods</span> <span class="o">-</span> <span class="no">Object</span><span class="p">.</span><span class="nf">public_methods</span>
<span class="c1"># =&gt; [:full_name, :contact, :phone=, :zipcode=, :email, :email=, :dob, :phone, :zipcode]</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">private_methods</span> <span class="o">-</span> <span class="no">Object</span><span class="p">.</span><span class="nf">private_methods</span>
<span class="c1"># =&gt; [:parse_date, :parse_phone, :contact_full_name, :parse_input, :name, :autoload, :autoload?]</span>
<span class="c1"># We can list the parameters of any given method, if any</span>
<span class="p">[</span><span class="ss">:parse_date</span><span class="p">,</span> <span class="ss">:parse_phone</span><span class="p">].</span><span class="nf">map</span><span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">obj</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="n">m</span><span class="p">).</span><span class="nf">parameters</span><span class="p">.</span><span class="nf">map</span><span class="p">{</span><span class="o">|</span><span class="n">params</span><span class="o">|</span> <span class="p">{</span><span class="ss">method: </span><span class="n">m</span><span class="p">,</span> <span class="ss">params: </span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="o">..-</span><span class="mi">1</span><span class="p">]}}.</span><span class="nf">flatten</span><span class="p">}</span>
<span class="c1"># =&gt; [[{:method=&gt;:parse_date, :params=&gt;[:date]}], [{:method=&gt;:parse_phone, :params=&gt;[:phone]}]]</span>
<span class="no">AnotherClass</span><span class="p">.</span><span class="nf">constants</span>
<span class="c1"># =&gt; [:SEPARATOR]</span>
<span class="no">AnotherClass</span><span class="p">.</span><span class="nf">name</span>
<span class="c1"># =&gt; "AnotherClass"</span>
<span class="c1"># We can infer what methods are setters</span>
<span class="p">(</span><span class="no">AnotherClass</span><span class="p">.</span><span class="nf">instance_methods</span> <span class="o">-</span> <span class="no">Object</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">).</span><span class="nf">select</span><span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">m</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s2">"="</span><span class="p">)}</span>
<span class="c1"># =&gt; [:phone=, :zipcode=, :email=]</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>The above is far from exhaustive. It is undoubtedly good to interact with the language constructs in Ruby dynamically. How we do, it is even better.</p>

<h1 id="dynamic-dispatch">Dynamic Dispatch</h1>

<p>Dynamic Dispatch is a technique that allows us to treat a method name as an argument that can be passed to another method that handles its execution. When we create instance methods for any given class in Ruby, we typically call them using the dot notation. As an example, consider the code below:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td>
<td class="code"><pre><span class="k">class</span> <span class="nc">MySimpleClass</span>
  <span class="k">def</span> <span class="nf">my_simple_method</span><span class="p">(</span><span class="n">string1</span><span class="p">,</span> <span class="n">string2</span><span class="p">)</span>
    <span class="n">string1</span> <span class="o">+</span> <span class="s2">" "</span> <span class="o">+</span> <span class="n">string2</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">obj</span> <span class="o">=</span> <span class="no">MySimpleClass</span><span class="p">.</span><span class="nf">new</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">my_simple_method</span><span class="p">(</span><span class="s2">"Hello"</span><span class="p">,</span><span class="s2">"World"</span><span class="p">)</span> <span class="c1"># =&gt; "Hello World"</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Alternatively, we obtain the same result using the method <code class="language-plaintext highlighter-rouge">:send</code> as follows:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">obj</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:my_simple_method</span><span class="p">,</span><span class="s2">"Hello"</span><span class="p">,</span><span class="s2">"World"</span><span class="p">)</span> <span class="c1"># =&gt; "Hello World"</span></code></pre></figure>

<p>How dynamic is Ruby? Let‚Äôs say that the last definition of <code class="language-plaintext highlighter-rouge">MySimpleClass</code> was the very first we created. If in a future moment I do:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td>
<td class="code"><pre><span class="k">class</span> <span class="nc">MySimpleClass</span>
  <span class="k">def</span> <span class="nf">some_other_method</span>
    <span class="nb">puts</span> <span class="s2">"Some other method"</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>and I request the instance methods of <code class="language-plaintext highlighter-rouge">MySimpleClass</code>, I obtain:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">MySimpleClass</span><span class="p">.</span><span class="nf">instance_methods</span> <span class="o">-</span> <span class="no">Object</span><span class="p">.</span><span class="nf">methods</span>
<span class="c1"># =&gt; [:some_method, :some_other_method, :my_first_method, :my_second_method]</span></code></pre></figure>

<p>And if we consider the very first definition of <code class="language-plaintext highlighter-rouge">MySimpleClass</code> is still accessible in memory, then we obtain:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">MySimpleClass</span><span class="p">.</span><span class="nf">instance_methods</span> <span class="o">-</span> <span class="no">Object</span><span class="p">.</span><span class="nf">methods</span>
<span class="c1"># =&gt; [:my_simple_method, :some_method, :some_other_method, :my_first_method, :my_second_method]</span></code></pre></figure>

<p>Therefore we can modify the struct of a class at the time of the execution of a program.</p>

<p>To show one form of Dynamic Dispatch in action, consider the following class:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td>
<td class="code"><pre><span class="k">class</span> <span class="nc">AnotherSimpleClass</span>
  <span class="k">def</span> <span class="nf">first_method_with_no_arguments</span>
    <span class="nb">puts</span> <span class="s2">"First method with no arguments"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">second_method_with_no_arguments</span>
    <span class="nb">puts</span> <span class="s2">"Second method with no arguments"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">third_method_with_no_arguments</span>
    <span class="nb">puts</span> <span class="s2">"Third method with no arguments"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">first_method_with_two_arguments</span><span class="p">(</span><span class="n">string1</span><span class="p">,</span> <span class="n">string2</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="n">string1</span> <span class="o">+</span> <span class="s2">" "</span> <span class="o">+</span> <span class="n">string2</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">second_method_with_two_argumetns</span><span class="p">(</span><span class="n">string1</span><span class="p">,</span> <span class="n">string2</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="n">string1</span> <span class="o">+</span> <span class="s2">" =&gt; "</span> <span class="o">+</span> <span class="n">string2</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>For any instance method in <code class="language-plaintext highlighter-rouge">AnotherSimpleClass</code>, we their argumetns:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="code"><pre><span class="n">obj</span> <span class="o">=</span> <span class="no">AnotherSimpleClass</span><span class="p">.</span><span class="nf">new</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:first_method_with_no_arguments</span><span class="p">).</span><span class="nf">parameters</span> <span class="c1"># =&gt; []</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:first_method_with_two_arguments</span><span class="p">).</span><span class="nf">parameters</span> <span class="c1"># =&gt; [[:req, :string1], [:req, :string2]]</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Therefore we can manipulate these language constructs for dynamically calling these methods. Let‚Äôs say that I want to call all methods with no arguments. I can do the following:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td>
<td class="code"><pre><span class="n">methods_no_arguments</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="nf">methods</span> <span class="o">-</span> <span class="no">Object</span><span class="p">.</span><span class="nf">methods</span><span class="p">).</span><span class="nf">select</span><span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">obj</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="n">m</span><span class="p">).</span><span class="nf">parameters</span><span class="p">.</span><span class="nf">empty?</span><span class="p">}</span>
<span class="c1"># =&gt; [:first_method_with_no_arguments, :second_method_with_no_arguments, :third_method_with_no_arguments]</span>
<span class="n">methods_no_arguments</span><span class="p">.</span><span class="nf">each</span><span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">obj</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span>
<span class="c1"># =&gt; First method with no arguments</span>
<span class="c1"># =&gt; Second method with no arguments</span>
<span class="c1"># =&gt; Third method with no arguments</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>For invoking only the methods with two arguments, I proceed as follows:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td>
<td class="code"><pre><span class="n">methods_two_arguments</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="nf">methods</span> <span class="o">-</span> <span class="no">Object</span><span class="p">.</span><span class="nf">methods</span><span class="p">).</span><span class="nf">select</span><span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">obj</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="n">m</span><span class="p">).</span><span class="nf">parameters</span><span class="p">.</span><span class="nf">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">}</span>
<span class="c1"># =&gt; [:first_method_with_two_arguments, :second_method_with_two_argumetns]</span>
<span class="n">methods_two_arguments</span><span class="p">.</span><span class="nf">each</span><span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">obj</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s2">"Hello"</span><span class="p">,</span> <span class="s2">"World"</span><span class="p">)}</span>
<span class="c1"># =&gt; Hello World</span>
<span class="c1"># =&gt; Hello =&gt; World</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>The method <code class="language-plaintext highlighter-rouge">send</code> will call any method in the respective class, including private methods. If you want to confine the dynamic execution of methods to public methods, you can use <code class="language-plaintext highlighter-rouge">public_send</code> instead.</p>

<h1 id="dynamic-methods">Dynamic Methods</h1>

<p>We already saw that we could add methods to an existing class as if we were creating the class for the first time. But there is a shorter way to do that. Consider our existing <code class="language-plaintext highlighter-rouge">AnotherSimpleClass</code>. We can dynamically define a new method as follows:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
<td class="code"><pre><span class="no">AnotherSimpleClass</span><span class="p">.</span><span class="nf">define_method</span> <span class="ss">:my_new_method</span> <span class="k">do</span> <span class="o">|</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="s2">"arg1 = </span><span class="si">#{</span><span class="n">arg1</span><span class="si">}</span><span class="s2">"</span>
  <span class="nb">puts</span> <span class="s2">"arg2 = </span><span class="si">#{</span><span class="n">arg2</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="n">obj</span> <span class="o">=</span> <span class="no">AnotherSimpleClass</span><span class="p">.</span><span class="nf">new</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">my_new_method</span><span class="p">(</span><span class="s2">"Hello"</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="c1"># =&gt; arg1 = Hello</span>
<span class="c1"># =&gt; arg2 = [1, 2, 3, 4]</span>

<span class="n">obj</span><span class="p">.</span><span class="nf">methods</span> <span class="o">-</span> <span class="no">Object</span><span class="p">.</span><span class="nf">methods</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:first_method_with_two_arguments</span><span class="p">,</span> <span class="ss">:second_method_with_two_argumetns</span><span class="p">,</span> <span class="ss">:my_new_method</span><span class="p">,</span> <span class="ss">:first_method_with_no_arguments</span><span class="p">,</span> <span class="ss">:second_method_with_no_arguments</span><span class="p">,</span> <span class="ss">:third_method_with_no_arguments</span><span class="p">]</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>When it comes to metaprogramming, the advantage of using <code class="language-plaintext highlighter-rouge">define_method</code> instead of <code class="language-plaintext highlighter-rouge">def method</code> is that we can easily pass the new method‚Äôs name as an argument in the same way we call other class‚Äô methods, which can be done at runtime.</p>

<h1 id="ghost-methods">Ghost Methods</h1>

<p>What happens when we call a method in Ruby? Consider the the instance <code class="language-plaintext highlighter-rouge">obj = AnotherSimpleClass</code>. When we call the method <code class="language-plaintext highlighter-rouge">:first_method_with_no_arguments</code>, Ruby looks at <code class="language-plaintext highlighter-rouge">obj.instance_methods</code> trying to find that method. If it finds it, it will call it. If it does not find it, then it will try to look for an implementation of a private method in <code class="language-plaintext highlighter-rouge">BasicObject</code> called <code class="language-plaintext highlighter-rouge">:method_missing</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="code"><pre><span class="no">BasicObject</span><span class="p">.</span><span class="nf">private_methods</span><span class="p">.</span><span class="nf">size</span> <span class="c1"># =&gt; 87</span>
<span class="no">BasicObject</span><span class="p">.</span><span class="nf">private_methods</span><span class="p">.</span><span class="nf">select</span><span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">m</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s2">"missing"</span><span class="p">)}</span>
<span class="c1"># =&gt; [:respond_to_missing?, :method_missing]</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>If Ruby does not find an implementation for <code class="language-plaintext highlighter-rouge">:method_missing</code> (I will talk about this later), then it calls <code class="language-plaintext highlighter-rouge">:method_undefined</code>. Let‚Äôs see this in practice:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="code"><pre><span class="n">obj</span> <span class="o">=</span> <span class="no">AnotherSimpleClass</span><span class="p">.</span><span class="nf">new</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">crazy</span>
<span class="c1"># =&gt; NoMethodError (undefined method `crazy' for #&lt;AnotherSimpleClass:0x00007fe3be15db60&gt;)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>We can‚Äôt call <code class="language-plaintext highlighter-rouge">method_undefined</code> using dot notation since it is a private method, as we can see here:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">BasicObject</span><span class="p">.</span><span class="nf">private_methods</span><span class="p">.</span><span class="nf">select</span><span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">m</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s2">"undefined"</span><span class="p">)}</span>
<span class="c1"># =&gt; [:method_undefined, :singleton_method_undefined]</span></code></pre></figure>

<p>But we call it using <code class="language-plaintext highlighter-rouge">:send</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">obj</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:method_undefined</span><span class="p">,</span> <span class="ss">:crazy</span><span class="p">)</span>
<span class="c1"># =&gt; NoMethodError (undefined method `method_undefined' for #&lt;AnotherSimpleClass:0x00007fe3be15db60&gt;)</span></code></pre></figure>

<p>Okay, we know how Ruby calls methods and what happens when it cannot find them. But what does it mean to loo for an implementation for <code class="language-plaintext highlighter-rouge">:method_missing</code>?</p>

<h2 id="method-missing">Method Missing</h2>

<p>There is no such thing as a compiler to enforce method calls in Ruby. Crazy, right? Even crazier is the fact that Ruby allows you to call methods that don‚Äôt exist! Let me give you one example of how useful this can be. I will create a data set called <code class="language-plaintext highlighter-rouge">data</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td>
<td class="code"><pre><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="p">{</span><span class="ss">name: </span><span class="s2">"John"</span><span class="p">,</span> <span class="ss">age: </span><span class="mi">25</span><span class="p">,</span> <span class="ss">gender: </span><span class="s2">"M"</span><span class="p">,</span> <span class="ss">state: </span><span class="s2">"CO"</span>
<span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="p">{</span><span class="ss">name: </span><span class="s2">"Mary"</span><span class="p">,</span> <span class="ss">age: </span><span class="mi">23</span><span class="p">,</span> <span class="ss">gender: </span><span class="s2">"F"</span><span class="p">,</span> <span class="ss">state: </span><span class="s2">"CO"</span><span class="p">}</span>
<span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="p">{</span><span class="ss">name: </span><span class="s2">"Gloria"</span><span class="p">,</span> <span class="ss">age: </span><span class="mi">20</span><span class="p">,</span> <span class="ss">gender: </span><span class="s2">"F"</span><span class="p">,</span> <span class="ss">state: </span><span class="s2">"FL"</span><span class="p">}</span>
<span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="p">{</span><span class="ss">name: </span><span class="s2">"Paul"</span><span class="p">,</span> <span class="ss">age: </span><span class="mi">23</span><span class="p">,</span> <span class="ss">gender: </span><span class="s2">"M"</span><span class="p">,</span> <span class="ss">state: </span><span class="s2">"CA"</span><span class="p">}</span>
<span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="p">{</span><span class="ss">name: </span><span class="s2">"Barb"</span><span class="p">,</span> <span class="ss">age: </span><span class="mi">26</span><span class="p">,</span> <span class="ss">gender: </span><span class="s2">"F"</span><span class="p">,</span> <span class="ss">state: </span><span class="s2">"TX"</span><span class="p">}</span>
<span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="p">{</span><span class="ss">name: </span><span class="s2">"Jerry"</span><span class="p">,</span> <span class="ss">age: </span><span class="mi">29</span><span class="p">,</span> <span class="ss">gender: </span><span class="s2">"M"</span><span class="p">,</span> <span class="ss">state: </span><span class="s2">"TX"</span><span class="p">}</span>
<span class="c1"># =&gt; [{:name=&gt;"John", :age=&gt;25, :gender=&gt;"M", :state=&gt;"CO"}, {:name=&gt;"Mary", :age=&gt;23, :gender=&gt;"F", :state=&gt;"CO"}, {:name=&gt;"Gloria", :age=&gt;20, :gender=&gt;"F", :state=&gt;"FL"}, {:name=&gt;"Paul", :age=&gt;23, :gender=&gt;"M", :state=&gt;"CA"}, {:name=&gt;"Barb", :age=&gt;26, :gender=&gt;"F", :state=&gt;"TX"}, {:name=&gt;"Jerry", :age=&gt;29, :gender=&gt;"M", :state=&gt;"TX"}]</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>I will now create a class <code class="language-plaintext highlighter-rouge">MyDatabase</code> and initialize it passing <code class="language-plaintext highlighter-rouge">data</code> as an argument. I will also create an implementation for <code class="language-plaintext highlighter-rouge">:method_missing</code> so we can take advantage of the dynamically creating and calling methods in Ruby:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td>
<td class="code"><pre><span class="k">class</span> <span class="nc">MyDatabase</span>
  <span class="nb">attr_reader</span> <span class="ss">:data</span>

  <span class="k">def</span> <span class="nf">initialize</span> <span class="n">data</span>
    <span class="vi">@data</span> <span class="o">=</span> <span class="n">data</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="c1"># I am looking for a pattern like part1_part2_part3 or part1_part2_part3_part4</span>
    <span class="c1"># the method split takes some character or string as a separator and creates an array</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s2">"_"</span><span class="p">)</span>

    <span class="c1"># In the first condition:</span>
    <span class="c1"># Check if there are three parts</span>
    <span class="c1"># Check if all the parts have content</span>
    <span class="c1"># Check if the array of hashes includes the informed key</span>

    <span class="c1"># In the second condition is similar to the first except this time:</span>
    <span class="c1"># Check if there are four parts</span>
    <span class="k">if</span> <span class="n">parts</span><span class="p">.</span><span class="nf">size</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">parts</span><span class="p">.</span><span class="nf">map</span><span class="p">{</span><span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="o">!</span><span class="n">a</span><span class="p">.</span><span class="nf">empty?</span> <span class="p">}.</span><span class="nf">uniq</span> <span class="o">==</span> <span class="p">[</span><span class="kp">true</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
       <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">keys</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nf">to_sym</span><span class="p">)</span>

      <span class="n">data</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">to_sym</span><span class="p">){</span><span class="o">|</span><span class="n">d</span><span class="o">|</span> <span class="n">d</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nf">to_sym</span><span class="p">]</span> <span class="o">==</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
      <span class="k">elsif</span> <span class="n">parts</span><span class="p">.</span><span class="nf">size</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">parts</span><span class="p">.</span><span class="nf">map</span><span class="p">{</span><span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="o">!</span><span class="n">a</span><span class="p">.</span><span class="nf">empty?</span> <span class="p">}.</span><span class="nf">uniq</span> <span class="o">==</span> <span class="p">[</span><span class="kp">true</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
        <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">keys</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="nf">to_sym</span><span class="p">)</span>

      <span class="n">data</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">1</span><span class="p">].</span><span class="nf">join</span><span class="p">(</span><span class="s2">"_"</span><span class="p">)){</span><span class="o">|</span><span class="n">d</span><span class="o">|</span> <span class="n">d</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="nf">to_sym</span><span class="p">]</span> <span class="o">==</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
    <span class="k">else</span>
      <span class="c1"># if the conditions I specified are not met, I pass control to the</span>
      <span class="c1"># original implementation of method_missing, which will not find</span>
      <span class="c1"># the method and will call :method_undefined</span>
      <span class="k">super</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>We can instantiate <code class="language-plaintext highlighter-rouge">MyDatabase</code> passing the array <code class="language-plaintext highlighter-rouge">data</code> as argument:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="code"><pre><span class="n">db</span> <span class="o">=</span> <span class="no">MyDatabase</span><span class="p">.</span><span class="nf">new</span> <span class="n">data</span>
<span class="n">db</span><span class="p">.</span><span class="nf">data</span>
<span class="c1"># =&gt; [{:name=&gt;"John", :age=&gt;25, :gender=&gt;"M", :state=&gt;"CO"}, {:name=&gt;"Mary", :age=&gt;23, :gender=&gt;"F", :state=&gt;"CO"}, {:name=&gt;"Gloria", :age=&gt;20, :gender=&gt;"F", :state=&gt;"FL"}, {:name=&gt;"Paul", :age=&gt;23, :gender=&gt;"M", :state=&gt;"CA"}, {:name=&gt;"Barb", :age=&gt;26, :gender=&gt;"F", :state=&gt;"TX"}, {:name=&gt;"Jerry", :age=&gt;29, :gender=&gt;"M", :state=&gt;"TX"}]</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>We can now do:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
<td class="code"><pre><span class="n">db</span><span class="p">.</span><span class="nf">find_by_name</span><span class="p">(</span><span class="s2">"Gloria"</span><span class="p">)</span>
<span class="c1"># =&gt; {:name=&gt;"Gloria", :age=&gt;20, :gender=&gt;"F", :state=&gt;"FL"}</span>
<span class="n">db</span><span class="p">.</span><span class="nf">find_by_state</span><span class="p">(</span><span class="s2">"TX"</span><span class="p">)</span>
<span class="c1"># =&gt; {:name=&gt;"Barb", :age=&gt;26, :gender=&gt;"F", :state=&gt;"TX"}</span>
<span class="n">db</span><span class="p">.</span><span class="nf">find_all_by_age</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>
<span class="c1"># =&gt; [{:name=&gt;"Mary", :age=&gt;23, :gender=&gt;"F", :state=&gt;"CO"}, {:name=&gt;"Paul", :age=&gt;23, :gender=&gt;"M", :state=&gt;"CA"}]</span>
<span class="n">db</span><span class="p">.</span><span class="nf">find_all_by_gender</span><span class="p">(</span><span class="s2">"F"</span><span class="p">)</span>
<span class="c1"># =&gt; [{:name=&gt;"Mary", :age=&gt;23, :gender=&gt;"F", :state=&gt;"CO"}, {:name=&gt;"Gloria", :age=&gt;20, :gender=&gt;"F", :state=&gt;"FL"}, {:name=&gt;"Barb", :age=&gt;26, :gender=&gt;"F", :state=&gt;"TX"}]</span>
<span class="n">db</span><span class="p">.</span><span class="nf">find_by_country</span><span class="p">(</span><span class="s2">"US"</span><span class="p">)</span>
<span class="c1"># =&gt; NoMethodError (undefined method `find_by_country' for #&lt;MyDatabase:0x00007fc14e91b3d0&gt;)</span>
<span class="n">db</span><span class="p">.</span><span class="nf">find_all_by_weight</span><span class="p">(</span><span class="mi">180</span><span class="p">)</span>
<span class="c1"># =&gt; NoMethodError (undefined method `find_all_by_weight' for #&lt;MyDatabase:0x00007fc14e91b3d0&gt;)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>This is just a toy example to show what kind of features one can build by dynamically manipulating language constructs in Ruby. Perhaps the most prominent example of dynamic method execution via implementations of <code class="language-plaintext highlighter-rouge">:method_missing</code> is the <a href="https://guides.rubyonrails.org/active_record_basics.html" target="_blank" rel="noopener noreferrer">ActiveRecord</a>, an object-relational mapping in Rails. Here is one <a href="https://github.com/rails/rails/blob/main/activerecord/lib/active_record/dynamic_matchers.rb" target="_blank" rel="noopener noreferrer">example</a>.</p>

<h1 id="dynamic-proxy">Dynamic Proxy</h1>

<p>In the previous example with <code class="language-plaintext highlighter-rouge">MyDatabase</code>, I receive whatever is passed on via method call and try to make sense of the call using pre-defined patterns. If the conditions specified are met, a method is dynamically called, returning the associated result. A similar approach is known as Dynamic Proxy. We still use the idea of Ghost Methods, but this time we forward the call to another method (which can be in another module or class). The most significant difference between Ghost Method and Dynamic Proxy is how to deal with responsibility. When working with Ghost Method in a particular class, you have the responsibility of implementing <code class="language-plaintext highlighter-rouge">:method_missing</code> and deciding when and how to give up and let Ruby call <code class="language-plaintext highlighter-rouge">:method_undefined</code>. With Dynamic Proxy, you forward the responsibility to another method and treat each situation according to whatever rules are in place.</p>

<p>Here is an example: we have class <code class="language-plaintext highlighter-rouge">Person</code>, and we want to ‚Äúmonitor‚Äù any call to a method <code class="language-plaintext highlighter-rouge">:parse</code>, but we don‚Äôt want to implement the logic. Instead, we will forward the logic to <code class="language-plaintext highlighter-rouge">JSON.parse</code>. So whatever rule <code class="language-plaintext highlighter-rouge">JSON</code> implemented for <code class="language-plaintext highlighter-rouge">:parse</code> will take place only when the method <code class="language-plaintext highlighter-rouge">:parse</code> is called for an instance of <code class="language-plaintext highlighter-rouge">Person</code>.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td>
<td class="code"><pre><span class="nb">require</span> <span class="s1">'json'</span>

<span class="k">class</span> <span class="nc">Person</span>
  <span class="nb">attr_accessor</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:age</span>

  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="ss">:parse</span>
      <span class="n">data</span> <span class="o">=</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">if</span> <span class="n">data</span><span class="p">.</span><span class="nf">keys</span><span class="p">.</span><span class="nf">map</span><span class="p">{</span><span class="o">|</span><span class="n">d</span><span class="o">|</span> <span class="nb">self</span><span class="p">.</span><span class="nf">respond_to?</span> <span class="n">d</span><span class="p">}.</span><span class="nf">uniq</span> <span class="o">==</span> <span class="p">[</span><span class="kp">true</span><span class="p">]</span>
        <span class="nb">self</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">"name"</span><span class="p">]</span>
        <span class="nb">self</span><span class="p">.</span><span class="nf">age</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">"age"</span><span class="p">]</span>
        <span class="nb">self</span><span class="p">.</span><span class="nf">to_s</span>
      <span class="k">end</span>
    <span class="k">else</span>
      <span class="k">super</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">to_s</span>
    <span class="s2">"Person =&gt; name: </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">, age: </span><span class="si">#{</span><span class="n">age</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>We can now call <code class="language-plaintext highlighter-rouge">:parse</code> in Person:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="code"><pre><span class="n">person</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="s1">'{"name": "John", "age": "25"}'</span><span class="p">)</span>
<span class="c1"># Person =&gt; name: John, age: 25</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>However, when we try to parse a different string, we obtain an error:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="code"><pre><span class="n">person</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="s1">'{"name" =&gt; "John", "age" =&gt; "25"}'</span><span class="p">)</span>
<span class="c1"># =&gt; unexpected token at '{"name" =&gt; "John", "age" =&gt; "25"}' (JSON::ParserError)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>And that decision was made by the <code class="language-plaintext highlighter-rouge">JSON</code>‚Äôs implementation of <code class="language-plaintext highlighter-rouge">:parse</code>.</p>

<p>If we try something different than parse and it is a method that is not present in the list of methods of <code class="language-plaintext highlighter-rouge">Person</code>‚Äôs ancestors, then we obtain the default behavior for undefined methods:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="code"><pre><span class="n">person</span><span class="p">.</span><span class="nf">infuse</span><span class="p">(</span><span class="s1">'{"name" =&gt; "John", "age" =&gt; "25"}'</span><span class="p">)</span>
<span class="c1"># =&gt; undefined method `infuse' for #&lt;Person:0x00007f9ba818a380&gt;</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<h1 id="blank-slate">Blank Slate</h1>

<p>Now let‚Äôs assume that for some reason, I thought that it was a great idea to implement a Dynamic Proxy for any method call starting with ‚Äúdisplay‚Äù for a new class called <code class="language-plaintext highlighter-rouge">MyNewClass</code>. My goal is to return just the object ID. So I create <code class="language-plaintext highlighter-rouge">MyNewClass</code> as follows:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td>
<td class="code"><pre><span class="k">class</span> <span class="nc">MyNewClass</span>

  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s2">"display"</span><span class="p">)</span>
      <span class="s2">"Object ID: </span><span class="si">#{</span><span class="nb">self</span><span class="p">.</span><span class="nf">__id__</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">else</span>
      <span class="k">super</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>So I try calling the method <code class="language-plaintext highlighter-rouge">:display_info</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="code"><pre><span class="n">obj</span> <span class="o">=</span> <span class="no">MyNewClass</span><span class="p">.</span><span class="nf">new</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">display_info</span>
<span class="c1"># =&gt; Object ID: 70138108065880</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Everything seems to be working nicely, but not quite. When I try calling just <code class="language-plaintext highlighter-rouge">:display</code>, the following happens:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">obj</span><span class="p">.</span><span class="nf">display</span>
<span class="c1"># =&gt; #&lt;MyNewClass:0x00007ffdce0165e8&gt;</span></code></pre></figure>

<p>This is not what I was expecting. This happens because <code class="language-plaintext highlighter-rouge">MyNewClass</code>‚Äôs parent class is <code class="language-plaintext highlighter-rouge">Object</code>, and <code class="language-plaintext highlighter-rouge">Object</code> implements an instance method <code class="language-plaintext highlighter-rouge">:display</code>. Therefore, when I call <code class="language-plaintext highlighter-rouge">:display</code>, Ruby looks for a method <code class="language-plaintext highlighter-rouge">:display</code> in the list of methods, including <code class="language-plaintext highlighter-rouge">Object</code>. Ruby will find <code class="language-plaintext highlighter-rouge">Object</code>‚Äôs implementation of <code class="language-plaintext highlighter-rouge">:display</code>, which just prints the bare object and returns <code class="language-plaintext highlighter-rouge">nil</code>. This is a simple example of a problem that can occur very frequently when using Dynamic Proxy, especially in larger projects: the name of a ‚ÄúGhost Method‚Äù can match the name of an existing method that belongs to one of the object‚Äôs class ancestors.</p>

<p>Most of the time, we need a fully-featured object with all the methods defined in <code class="language-plaintext highlighter-rouge">Object</code>. Some other times, we need some simpler. A class with a minimum number of methods is referred to as Blank Slate. One way to solve our problem is to modify <code class="language-plaintext highlighter-rouge">MyNewClass</code> to inherit from <code class="language-plaintext highlighter-rouge">BasicObject</code> instead of implicitly inheriting from <code class="language-plaintext highlighter-rouge">Object</code>.</p>

<p>The class <code class="language-plaintext highlighter-rouge">Object</code> has 58 instance methods:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Object</span><span class="p">.</span><span class="nf">instance_methods</span>
<span class="c1"># =&gt; [:instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :instance_variable_get, :instance_variable_set, :instance_variables, :singleton_method, :method, :public_send, :define_singleton_method, :public_method, :extend, :to_enum, :enum_for, :&lt;=&gt;, :===, :=~, :!~, :eql?, :respond_to?, :freeze, :inspect, :object_id, :send, :to_s, :display, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :yield_self, :then, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :equal?, :!, :__id__, :==, :instance_exec, :!=, :instance_eval, :__send__]</span></code></pre></figure>

<p>The class <code class="language-plaintext highlighter-rouge">BasicObject</code> has only 8 instance methods:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">BasicObject</span><span class="p">.</span><span class="nf">instance_methods</span>
<span class="c1"># =&gt; [:equal?, :!, :__id__, :==, :instance_exec, :!=, :instance_eval, :__send__]</span></code></pre></figure>

<p>More importantly, <code class="language-plaintext highlighter-rouge">BasicObject</code> does not implement <code class="language-plaintext highlighter-rouge">:display</code>. So we can modify <code class="language-plaintext highlighter-rouge">MyNewClass</code> as follows:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">MyNewClass</span> <span class="o">&lt;</span> <span class="no">BasicObject</span>

  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s2">"display"</span><span class="p">)</span>
      <span class="s2">"Object ID: </span><span class="si">#{</span><span class="nb">self</span><span class="p">.</span><span class="nf">__id__</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">else</span>
      <span class="k">super</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">MyNewClass</code> now inherits from <code class="language-plaintext highlighter-rouge">BasicObject</code>, which makes <code class="language-plaintext highlighter-rouge">MyNewClass</code> a Blank Slate. Of course, we lose most of the functionalities we would need for a more comprehensive class, including all functionality given by the <code class="language-plaintext highlighter-rouge">Kernel</code>. But for the sake of this illustration, with the modification above, we can now call all variations of ‚Äúdisplay‚Äù, including <code class="language-plaintext highlighter-rouge">:display</code>, and we will obtain the expected result:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="code"><pre><span class="n">obj</span> <span class="o">=</span> <span class="no">MyNewClass</span><span class="p">.</span><span class="nf">new</span>
<span class="nb">puts</span> <span class="n">obj</span><span class="p">.</span><span class="nf">display</span>
<span class="c1"># =&gt; Object ID: 70183204985940</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<h1 id="code-that-writes-code">Code that Writes Code</h1>

<p>I told you before that I don‚Äôt like the ‚Äúcode that writes code‚Äù definition of metaprogramming, but that doesn‚Äôt mean we can‚Äôt have fun with it. Here is a simple example of creating classes and instantiating an object for these classes dynamically. Imagine that I have two files: <code class="language-plaintext highlighter-rouge">person.csv</code></p>

<figure class="highlight"><pre><code class="language-csv" data-lang="csv">name,age,gender,state
John,25,M,CO
Mary,23,F,CO
Gloria,20,F,FL
Paul,23,M,CA
Barb,26,F,TX
Jerry,29,M,TX</code></pre></figure>

<p>and <code class="language-plaintext highlighter-rouge">product.csv</code></p>

<figure class="highlight"><pre><code class="language-csv" data-lang="csv">code,name,price
T252XL,Ink Cartridge,34.99
A320,Printer,299.32
532A,Monitor,345.62
9932,Mouse,32.95</code></pre></figure>

<p>I will write a code that will read the content of <code class="language-plaintext highlighter-rouge">person.csv</code>, create a class <code class="language-plaintext highlighter-rouge">Person</code> and define its attributes based on the first line of the file and then instantiate objects of <code class="language-plaintext highlighter-rouge">Person</code> with the data in the remainder of the file. In fact, the code will work for any csv file following the same pattern, therefore the same will ocurr for <code class="language-plaintext highlighter-rouge">product.csv</code>.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td>
<td class="code"><pre><span class="c1"># process_csv.rb</span>

<span class="n">files</span> <span class="o">=</span> <span class="no">Dir</span><span class="p">[</span><span class="s2">"*.csv"</span><span class="p">]</span>

<span class="n">database</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">files</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">filename</span><span class="o">|</span>
  <span class="n">class_name</span> <span class="o">=</span> <span class="n">filename</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s2">"."</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="nf">capitalize</span>
  <span class="n">lines</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">readlines</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
  <span class="vg">$attributes</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">strip</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s2">","</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_sym</span><span class="p">)</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="o">..-</span><span class="mi">1</span><span class="p">].</span><span class="nf">map</span><span class="p">{</span><span class="o">|</span><span class="n">d</span><span class="o">|</span> <span class="n">d</span><span class="p">.</span><span class="nf">strip</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s2">","</span><span class="p">)}</span>

  <span class="n">new_class</span> <span class="o">=</span> <span class="no">Class</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Object</span><span class="p">)</span> <span class="k">do</span>
    <span class="nb">attr_accessor</span> <span class="o">*</span><span class="vg">$attributes</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
      <span class="vg">$attributes</span><span class="p">.</span><span class="nf">zip</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">attribute</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
        <span class="nb">instance_variable_set</span><span class="p">(</span><span class="s2">"@</span><span class="si">#{</span><span class="n">attribute</span><span class="p">.</span><span class="nf">to_s</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">my_class</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">const_set</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">new_class</span><span class="p">)</span>

  <span class="n">collection</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">d</span><span class="o">|</span>
    <span class="n">new_class</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">database</span> <span class="o">&lt;&lt;</span> <span class="p">{</span><span class="ss">class: </span><span class="n">new_class</span><span class="p">,</span> <span class="ss">data: </span><span class="n">collection</span><span class="p">}</span>
<span class="k">end</span>

<span class="n">database</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">db</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">db</span><span class="p">[</span><span class="ss">:class</span><span class="p">]</span>
  <span class="nb">puts</span> <span class="s2">"==============================================================================="</span>
  <span class="n">db</span><span class="p">[</span><span class="ss">:data</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="n">row</span><span class="p">.</span><span class="nf">inspect</span>
  <span class="k">end</span>
  <span class="nb">puts</span> <span class="s2">""</span>
<span class="k">end</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Now I can run <code class="language-plaintext highlighter-rouge">process_csv.rb</code>, which returns the following:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">Person
<span class="o">===============================================================================</span>
<span class="c">#&lt;Person:0x00007fb7a403bea8 @name="John", @age="25", @gender="M", @state="CO"&gt;</span>
<span class="c">#&lt;Person:0x00007fb7a403b930 @name="Mary", @age="23", @gender="F", @state="CO"&gt;</span>
<span class="c">#&lt;Person:0x00007fb7a403b188 @name="Gloria", @age="20", @gender="F", @state="FL"&gt;</span>
<span class="c">#&lt;Person:0x00007fb7a403a648 @name="Paul", @age="23", @gender="M", @state="CA"&gt;</span>
<span class="c">#&lt;Person:0x00007fb7a4039360 @name="Barb", @age="26", @gender="F", @state="TX"&gt;</span>
<span class="c">#&lt;Person:0x00007fb7a4038e88 @name="Jerry", @age="29", @gender="M", @state="TX"&gt;</span>

Product
<span class="o">===============================================================================</span>
<span class="c">#&lt;Product:0x00007fb7a48d52d0 @code="T252XL", @name="Ink Cartridge", @price="34.99"&gt;</span>
<span class="c">#&lt;Product:0x00007fb7a48d4f88 @code="A320", @name="Printer", @price="299.32"&gt;</span>
<span class="c">#&lt;Product:0x00007fb7a48d4ba0 @code="532A", @name="Monitor", @price="345.62"&gt;</span>
<span class="c">#&lt;Product:0x00007fb7a48d4768 @code="9932", @name="Mouse", @price="32.95"&gt;</span></code></pre></figure>

<h1 id="refactoring-with-metaprogramming">Refactoring with Metaprogramming</h1>

<p>Now that we have seen some of the basics of metaprogramming in Ruby let‚Äôs review a very interesting example Perrotta discusses in his book (slightly modified here for simplicity). Imagine that you are analyzing a very strange legacy Ruby code full of duplications. Your task is to improve it as much as possible. You receive two files: <code class="language-plaintext highlighter-rouge">data_source.rb</code> and <code class="language-plaintext highlighter-rouge">duplicated.rb</code>. The <code class="language-plaintext highlighter-rouge">data_source.file</code> is partially shown below:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
<td class="code"><pre><span class="c1"># data_source.rb</span>

<span class="k">class</span> <span class="nc">DS</span>
  <span class="k">def</span> <span class="nf">initialize</span> <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">get_cpu_info</span><span class="p">(</span><span class="n">workstation_id</span><span class="p">)</span> <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">get_cpu_price</span><span class="p">(</span><span class="n">workstation_id</span><span class="p">)</span> <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">get_mouse_info</span><span class="p">(</span><span class="n">workstation_id</span><span class="p">)</span> <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">get_mouse_info</span><span class="p">(</span><span class="n">workstation_id</span><span class="p">)</span> <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">get_keyboard_info</span><span class="p">(</span><span class="n">workstation_id</span><span class="p">)</span> <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">get_keyboard_price</span><span class="p">(</span><span class="n">workstation_id</span><span class="p">)</span> <span class="c1"># ...</span>
  <span class="c1"># ... etc</span>
<span class="k">end</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>The exact logic of <code class="language-plaintext highlighter-rouge">DS</code> is suppressed in the display. Just assume that when you pass a <code class="language-plaintext highlighter-rouge">workstation_id</code> as an argument to one of the methods in <code class="language-plaintext highlighter-rouge">DS</code>, <code class="language-plaintext highlighter-rouge">DS</code> will connect to a database and return the required information:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td>
<td class="code"><pre><span class="n">ds</span> <span class="o">=</span> <span class="no">DS</span><span class="p">.</span><span class="nf">new</span>
<span class="n">ds</span><span class="p">.</span><span class="nf">get_cpu_info</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>     <span class="c1"># =&gt; "2.9 Ghz quad-core"</span>
<span class="n">ds</span><span class="p">.</span><span class="nf">get_cpu_price</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>    <span class="c1"># =&gt; 120</span>
<span class="n">ds</span><span class="p">.</span><span class="nf">get_mouse_info</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>   <span class="c1"># =&gt; "Wireless Touch"</span>
<span class="n">ds</span><span class="p">.</span><span class="nf">get_mouse_price</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  <span class="c1"># =&gt; 60</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>And here is <code class="language-plaintext highlighter-rouge">duplicated.rb</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td>
<td class="code"><pre><span class="k">class</span> <span class="nc">Computer</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">computer_id</span><span class="p">,</span> <span class="n">data_source</span><span class="p">)</span>
    <span class="vi">@id</span> <span class="o">=</span> <span class="n">computer_id</span>
    <span class="vi">@data_source</span> <span class="o">=</span> <span class="n">data_source</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">cpu</span>
    <span class="n">info</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">get_cpu_info</span><span class="p">(</span><span class="vi">@id</span><span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">get_cpu_price</span><span class="p">(</span><span class="vi">@id</span><span class="p">)</span>
    <span class="s2">"CPU: </span><span class="si">#{</span><span class="n">info</span><span class="si">}</span><span class="s2"> ($</span><span class="si">#{</span><span class="n">price</span><span class="si">}</span><span class="s2">)"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">mouse</span>
    <span class="n">info</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">get_mouse_info</span><span class="p">(</span><span class="vi">@id</span><span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">get_mouse_price</span><span class="p">(</span><span class="vi">@id</span><span class="p">)</span>
    <span class="s2">"Mouse: </span><span class="si">#{</span><span class="n">info</span><span class="si">}</span><span class="s2"> ($</span><span class="si">#{</span><span class="n">price</span><span class="si">}</span><span class="s2">)"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">keyboard</span>
    <span class="n">info</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">get_keyboard_info</span><span class="p">(</span><span class="vi">@id</span><span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">get_keyboard_price</span><span class="p">(</span><span class="vi">@id</span><span class="p">)</span>
    <span class="s2">"Keyboard: </span><span class="si">#{</span><span class="n">info</span><span class="si">}</span><span class="s2"> ($</span><span class="si">#{</span><span class="n">price</span><span class="si">}</span><span class="s2">)"</span>
  <span class="k">end</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>You know where this is going, right? You can now identify the duplications and how we can use the strategies we previously discussed to improve this code. First, we can use Dynamic Methods and Dynamic Dispatch:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td>
<td class="code"><pre><span class="k">class</span> <span class="nc">Computer</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">computer_id</span><span class="p">,</span> <span class="n">data_source</span><span class="p">)</span>
    <span class="vi">@id</span> <span class="o">=</span> <span class="n">computer_id</span>
    <span class="vi">@data_source</span> <span class="o">=</span> <span class="n">data_source</span>
    <span class="n">data_source</span><span class="p">.</span><span class="nf">methods</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="sr">/^get_(.*)_info$/</span><span class="p">)</span> <span class="p">{</span> <span class="no">Computer</span><span class="p">.</span><span class="nf">define_component</span> <span class="vg">$1</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="c1"># Added explanation:</span>
  <span class="c1"># Notice that we just need the name of the resource</span>
  <span class="c1"># so it suffices to get the name from get_*_info methods since get_*_price</span>
  <span class="c1"># repeats the name of the resource.</span>
  <span class="c1"># The $1 is just a global variable that words as a type of placeholder for</span>
  <span class="c1"># a later use.</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_component</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="n">define_method</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">info</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">send</span> <span class="s2">"get_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_info"</span><span class="p">,</span> <span class="vi">@id</span>
      <span class="n">price</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">send</span> <span class="s2">"get_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_price"</span><span class="p">,</span> <span class="vi">@id</span>
      <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">capitalize</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">info</span><span class="si">}</span><span class="s2"> ($</span><span class="si">#{</span><span class="n">price</span><span class="si">}</span><span class="s2">)"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Second, we can use Ghost Methods, and a Dynamic Proxy that is also a Blank Slate:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
<td class="code"><pre><span class="k">class</span> <span class="nc">Computer</span> <span class="o">&lt;</span> <span class="no">BasicObject</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">computer_id</span><span class="p">,</span> <span class="n">data_source</span><span class="p">)</span>
    <span class="vi">@id</span> <span class="o">=</span> <span class="n">computer_id</span>
    <span class="vi">@data_source</span> <span class="o">=</span> <span class="n">data_source</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">super</span> <span class="k">if</span> <span class="o">!</span><span class="vi">@data_source</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="s2">"get_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_info"</span><span class="p">)</span>
    <span class="n">info</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">send</span> <span class="s2">"get_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_info"</span><span class="p">,</span> <span class="vi">@id</span>
    <span class="n">price</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">send</span> <span class="s2">"get_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_price"</span><span class="p">,</span> <span class="vi">@id</span>
    <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">capitalize</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">info</span><span class="si">}</span><span class="s2"> ($</span><span class="si">#{</span><span class="n">price</span><span class="si">}</span><span class="s2">)"</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>And so, we used all four strategies for metaprogramming in Ruby that we discussed in this post. Notice the method <code class="language-plaintext highlighter-rouge">:respond_to?</code> in the <code class="language-plaintext highlighter-rouge">Computer</code>‚Äôs implementation of <code class="language-plaintext highlighter-rouge">:method_missing</code>. When an object calls <code class="language-plaintext highlighter-rouge">:respond_to?</code>, Ruby will respond if that object implements the method passed as an argument. You could ask: ‚ÄúBut isn‚Äôt the idea of <code class="language-plaintext highlighter-rouge">:method_missing</code> to dynamically implement a method that does not exist?‚Äù Correct. However, we are implementing the logic of method missing in <code class="language-plaintext highlighter-rouge">Computer</code> and checking if an associated method exists in <code class="language-plaintext highlighter-rouge">DS</code>. We need that method to exist in <code class="language-plaintext highlighter-rouge">DS</code> to make this logic work; therefore, we first check if the method exists in <code class="language-plaintext highlighter-rouge">DS</code>, and if not, we call the original implementation of <code class="language-plaintext highlighter-rouge">:method_missing</code>. Otherwise, we will continue with our implementation.</p>

<h1 id="there-is-more">There is More</h1>

<p>I briefly discussed metaprogramming strategies with Ruby in this post, such as Dynamic Dispatch, Dynamic Methods, Ghost Methods, Dynamic Proxy, and Blank Slate. Paolo Perrotta refers to these strategies as ‚Äúspells.‚Äù In his book, many other spells are discussed: Around Alias, Class Extension, Class Instance Variable, Class Macro, Clean Room, Code Processor, Deferred Evaluation, Flat Scope, Hook Method, Kernel Method, Lazy Instance Method, Mimic Method, Monkey Patch, Namespace, Nil Guard, Object Extension, Open Class, Prepend Wrapper, Refinement, Refinement Wrapper, Sandbox, Scope Gate, Self Yield, Shared Scope, Singleton Method, String of Code, and Symbol to Proc. Trust me: I didn‚Äôt even scratch the surface. There is much more to metaprogramming in Ruby.</p>

<h1 id="conclusions">Conclusions</h1>

<p>Ruby is a dynamic language by design. Its syntax is concise and elegant, and its constructs are available for meaningful manipulations, which takes object-oriented programming to its full potential and makes metaprogramming in Ruby a delightful experience. For this reason, I find Ruby the best language for prototyping I know.</p>

  </article><div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname  = 'davidwsilva';
      var disqus_identifier = '/blog/2022/metaprogramming-ruby';
      var disqus_title      = "Metaprogramming in Ruby";
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" target="_blank" rel="noopener noreferrer">comments powered by Disqus.</a>
</noscript>

</div>

  </div>

  <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        ¬© Copyright 2023 David W. Silva. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="noopener noreferrer">Unsplash</a> and <a href="https://www.pexels.com/" target="_blank" rel="noopener noreferrer">Pexels</a>

      </div>
    </footer>

  <!-- JavaScripts -->
  <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

  <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

  <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
  
  <!-- Medium Zoom JS -->
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="/assets/js/zoom.js"></script><!-- Load Common JS -->
  <script src="/assets/js/common.js"></script>

  <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

  
</body>

</html>
